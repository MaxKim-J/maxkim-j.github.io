---
title: React Queryë¥¼ ì˜ ì¨ë³´ê¸° ìœ„í•œ íƒêµ¬ [1]
description: tkdodo React Query í¬ìŠ¤íŒ… ë…í›„ê° (1~11)
date: 2023-12-10
category: tech
tags:
  - react
  - react-query
---

ìµœê·¼ì— íšŒì‚¬ì—ì„œ ì‚¬ìš©í•˜ëŠ” React Queryë¥¼ ë” ì˜ ì“°ê¸° ìœ„í•œ ë…¼ì˜ë¥¼ í•˜ë‹¤ê°€ ì´ì•¼ê¸°ê°€ ë‚˜ì˜¨ ê²ƒì´ React Queryì˜ ê¸°ì—¬ì ì¤‘ í•œ ë¶„ì¸ [tkdodo](https://tkdodo.eu/blog)ì˜ React Query í¬ìŠ¤íŒ… ì‹œë¦¬ì¦ˆì˜€ìŠµë‹ˆë‹¤. React Queryë¥¼ ë” ì˜ ì“°ê¸° ìœ„í•œ ê³ ë¯¼ë“¤ê³¼ í”„ë™í‹°ìŠ¤ë“¤ì´ ë§ì•„ ì •ë§ ì¢‹ì€ ì°¸ê³ ìë£Œì˜€ëŠ”ë°ìš”.

ìš”ì¦˜ ìš” í¬ìŠ¤íŒ… íƒ€ë˜ë¥¼ ì­‰ ì½ì–´ë³´ê³  ìˆìŠµë‹ˆë‹¤. í˜„ì¬ ê¸€ì€ 23ê°œì¸ë°, ëŒ€ì¶© ì ˆë°˜ ì •ë„ì¸ 11ê°œì˜ í¬ìŠ¤íŒ…ì„ ì½ê³  ê°ê°ì˜ ê¸€ì— ëŒ€í•œ ê°„ë‹¨í•œ ë…í›„ê°ì„ ì‘ì„±í•´ ë´¤ìŠµë‹ˆë‹¤. ë‚´ìš©ì„ ìš”ì•½/ì¸ìš©í•˜ê³ , ì œ ëŠë‚Œì´ë‚˜ ìƒê°ì„ ë§ë¶™ì´ëŠ” ë°©ì‹ì…ë‹ˆë‹¤. ë‚˜ì¤‘ì— ë‹¤ ì½ê³  2íƒ„ë„ ì¨ë³´ê² ìŠµë‹ˆë‹¤.

# [1. practical react query](https://tkdodo.eu/blog/practical-react-query)

> So it seems that we have always been treating thisÂ *server state*Â like any otherÂ *client state*. Except that when it comes toÂ *server state*Â (think: A list of articles that you fetch, the details of a User you want to display, ...), your app does not own it. We have only **borrowed** it to display the most recent version of it on the screen for the user. It is the server who owns the data.

> To me, that introduced a paradigm shift in how to think about data. If we can leverage the cache to display data that **we do not own**, there isn't really much left that is real client state thatÂ *also*Â needs to be made available to the whole app.

ë°ì´í„°ë¥¼ ì†Œìœ ê¶Œì˜ ê°œë…ìœ¼ë¡œ êµ¬ë¶„í•œ ê²ƒì´ ëª…ì¾Œí•˜ë‹¤ê³  ëŠê»´ì¡ŒìŠµë‹ˆë‹¤. ì´ê²ƒì€ ì²˜ìŒ RQë¥¼ ì ‘í–ˆì„ë•Œë¶€í„° ëŠë‚€ ê²ƒì¸ë°ìš”.

ì„œë²„ì—ì„œ ë°ì´í„°ë¥¼ ë¹Œë ¤(borrow)ì„œ ê°€ì¥ ìµœì‹ ì˜ ë²„ì „ì„ ë³´ì—¬ì£¼ëŠ” ì±…ì„ë§Œì´ í´ë¼ì´ì–¸íŠ¸ì— ì¡´ì¬í•œë‹¤ëŠ” ë§ë¡œ, ë°ì´í„° ì†Œìœ ê¶Œì— ë”°ë¥¸ ì±…ì„ì„ ëª…í™•íˆ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ êµ¬ë¶„ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¡´ì¬ì˜ ì‹œì‘ì ì´ ë˜ê¸°ë„ í•˜ê³ , ê°œë°œì˜ ë¡œë“œë§µì´ ì–´ë””ì— ì§‘ì¤‘í• ì§€ë„ ëª…ì‹œê°€ ë˜ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.

<br/>

> (Don't use the queryCache as a local state manager) If you tamper with the queryCache (`queryClient.setQueryData`), it should only be for optimistic updates or for writing data that you receive from the backend after a mutation. Remember that every background refetch might override that data, soÂ [use](https://reactjs.org/docs/hooks-state.html)Â [something](https://zustand.surge.sh/)Â [else](https://redux.js.org/)Â for local state.

ëª…ì‹œì ìœ¼ë¡œ ë°ì´í„°ë¥¼ setí•˜ëŠ” ê²ƒì„ ìµœëŒ€í•œ ì§€ì–‘í•˜ë¼ëŠ” ë§ë¡œ í•´ì„ì´ ë˜ì—ˆìŠµë‹ˆë‹¤. ë§¥ë½ìœ¼ë¡œ ë³¼ë•Œ ì•ì—ì„œ ë§í–ˆë˜ ìƒíƒœì˜ ë¶„ë¦¬, ê·¸ë¦¬ê³  background fetchingì´ë¼ëŠ” ë™ì‘ì´ ìµœëŒ€í•œ ì˜ë„ëœ ë°” ê·¸ëŒ€ë¡œ ì´ë£¨ì–´ì§€ê²Œ í•˜ë ¤ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.

"use something else"ë¡œ ì œì‹œí•œê²Œ reactì˜ state, zustand, reduxì¸ë° RQ ì—­ì‹œ êµ¬ì¡°ì ìœ¼ë¡œëŠ” Providerê°€ ìˆëŠ” íƒ‘ë‹¤ìš´ ë°©ì‹ì˜ ìƒíƒœê´€ë¦¬ë¥¼ í•˜ê³  ìˆìœ¼ë‹ˆ ì´ ë§¥ë½ì—ì„œ ë§ëŠ” ë„êµ¬ë“¤ì„ ì œì‹œí•œê²Œ ì•„ë‹Œê°€ ì‹¶ìŠµë‹ˆë‹¤.

# [2. React Query Data Transformations](https://tkdodo.eu/blog/react-query-data-transformations)

> **On the backend**

ì¼í•˜ë‹¤ë³´ë©´ ë°±ì—”ë“œì—ì„œ ë°ì´í„°ë¥¼ ë°”ê¿”ì¤„ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ê°€ë” ìŠì–´ë¨¹ê¸°ë„ í•˜ê¸°ì— ì¢‹ì€ í¬ì¸íŠ¸ë¥¼ ì§šì–´ì¤¬ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤. ì—­ì‹œ ë‹¤ ë‚´ê°€ í•´ì•¼ í•˜ëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤.

ì–´ë–¤ ë°ì´í„° ë³€ê²½(transform)ë“¤ì€ ë°±ì—”ë“œì—ì„œ í•˜ëŠ”ê²Œ ë” ë§ì„ ë•Œë„ ìˆìŠµë‹ˆë‹¤. ë˜í•œ ë°ì´í„°ë¥¼ ë¹Œë¦¬ëŠ” í´ë¼ì´ì–¸íŠ¸ê°€ ì—¬ëŸ¬ê°œë¼ë©´ ë°±ì—”ë“œì—ì„œ ë‹¨ì¼ì„±ì„ ë³´ì¥í•˜ëŠ”ê²Œ ë” ì¢‹ì„ ë•Œë„ ìˆìŠµë‹ˆë‹¤. ë°±ì—”ë“œì˜ ë°ì´í„°ë¥¼ ë³€ê²½í•˜ëŠ” ë¡œì§ì´ í´ë¼ì´ì–¸íŠ¸ì— ë§ì´ ë“¤ì–´ìˆì„ìˆ˜ë¡ ì–´ë””ì„œ ë­” ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ íŒë‹¨í•˜ê¸° í•­ìƒ ì–´ë ¤ì›Œì¡ŒìŠµë‹ˆë‹¤.

<br/>


> But if you pass a selector, you are now only subscribed to the result of the selector function. This is quite powerful,

selectorëŠ” queryê°€ watchí•´ì•¼í•  ë³€ê²½ì ì„ ì¢íˆëŠ” ì—­í• ë„ ê°™ì´ í•©ë‹ˆë‹¤.

<br/>

---

ì‚¬ì‹¤ ì´ ê¸€ì—ëŠ” ë°ì´í„°ë¥¼ ë³€ê²½í•˜ëŠ” ì¥ì†Œ(backend, queryFn, render function, select) ì´ë ‡ê²Œ ë³´ì—¬ì£¼ê³  `select`ê°€ ê°€ì¥ ë‹¨ì ì´ ì ì–´ ë³´ì´ì§€ë§Œ

ê²½í—˜ìƒ ë°±ì—”ë“œì˜ ì‘ë‹µì„ queryì˜ ê²°ê³¼ê°’ì— ê·¸ëŒ€ë¡œ ë„£ì–´ì•¼ ì¢‹ì€ ìƒí™©ì´ ê½¤ ë§ì•˜ìŠµë‹ˆë‹¤. queryì™€ íŠ¹ì • ë°±ì—”ë“œ ë°ì´í„°ë¥¼ 1:1ë¡œ ëŒ€ì‘ì‹œí‚¤ëŠ”ê²Œ ë” ë‹¨ìˆœí•œ ë©˜íƒˆ ëª¨ë¸ì´ê³ , ì—¬ëŸ¬ ì‘ì—…ìê°€ ë¬¸ì„œí™” ë“±ìœ¼ë¡œ ë°ì´í„°ì˜ ìƒê¹€ìƒˆë¥¼ ì‰½ê²Œ ì•Œ ìˆ˜ ìˆëŠ” ë°±ì—”ë“œì˜ ì‘ë‹µê°’ì´ë¼ëŠ” ê³µë™ì˜ ì´í•´ ìœ„ì—ì„œ ì‘ì—…ì„ í•˜ëŠ”ê²Œ ë” ë‚˜ì•˜ì–´ìš”. `select`ëŠ” ì‰½ê²Œ ì•”ë¬µì§€ê°€ ë˜ê±°ë‚˜ `select`ê°€ ì„¤ì •ëœ queryë¡œëŠ” íŠ¹ì • ê¸°ëŠ¥ì—ì„œ ì›í•˜ëŠ” ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ê°€ ì—†ì–´ì„œ ì¤‘ë³µ íŒ¨ì¹­ì„ ìœ ë°œí•  ìˆ˜ë„ ìˆì—ˆìŠµë‹ˆë‹¤.

ê·¸ë˜ì„œ ê²°êµ­ ë°±ì—”ë“œì˜ ì‘ë‹µì„ queryì— ì‚´ë ¤ë‘ê³ , ì´ queryì—ì„œ ë‚˜ì˜¨ ì‘ë‹µì„ `select`í•´ì£¼ëŠ” ê²½ìš°ê°€ í™•ì¥ì„±ì´ ë” ë‚˜ì„ ìˆ˜ë„ ìˆë‹¤ëŠ” ìƒê°ì€ ë“¤ì—ˆìŠµë‹ˆë‹¤. ì´ëŸ° ì „ì œë¼ë©´ ì›ë˜ì˜ queryì—ì„œ ë‚˜ì˜¨ ì‘ë‹µì„ `select`í•˜ê¸° ìœ„í•´ ë˜ queryë¥¼ ì“°ëŠ”ê²Œ ì˜¤ë²„í‚¬ì²˜ëŸ¼ ëŠê»´ì§ˆ ìˆ˜ë„ ìˆì–´ì„œ render functionì—ì„œì˜ ë°ì´í„° transformë„ ë¹ˆë²ˆí•˜ê²Œ ì´ë¤„ì§ˆ ìˆ˜ ìˆì„ ê²ƒ ê°™ë„¤ìš”.

# [3. React Query Render Optimizations](https://tkdodo.eu/blog/react-query-render-optimizations)

> Render optimizations are an advanced concept for any app. React Query already comes with very good optimizations and defaults out of the box, and most of the time, no further optimizations are needed.

> I'd take an "unnecessary re-render" over a "missing render-that-should-have-been-there" all day every day.

Reactì™€ ê´€ë ¨ëœ ìµœì í™” ì°ì—ì„œ í•­ìƒ "ìµœì í™”ë¥¼ í•˜ì"ì™€ "ë°œì í™”ë¥¼ í•˜ì§€ë§ì"ëŠ” í•­ìƒ ê°™ì´ ë‚˜ì˜¤ëŠ” ë§ì¸ ê²ƒ ê°™ìŠµë‹ˆë‹¤. [Kent Doddsì˜ ì¢‹ì€ ê¸€ë„ ë ˆí¼ëŸ°ìŠ¤](https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render)ë¥¼ ê±¸ì–´ë†¨ìŠµë‹ˆë‹¤.

<br/>

> I'm quite proud of this feature, given that it was my first major contribution to the library. If you setÂ `notifyOnChangeProps`Â toÂ `'tracked'`, React Query will keep track of the fields you are using during render, and will use this to compute the list.

v4ë¶€í„° ê¸°ë³¸ìœ¼ë¡œ ì ìš©ë˜ì—ˆë˜ tracked queryëŠ” ì •ë§ ì˜ ë§Œë“  ê¸°ëŠ¥ì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤. ì‚¬ìš©ìê°€ ì‹ ê²½ì¨ì•¼ í•  ê²ƒì„ ì ì ˆí•˜ê²Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‹¨ìœ¼ë¡œ ê°€ì ¸ì˜¤ë©° ë°”ê¹¥ìœ¼ë¡œ ë‚˜ê°€ëŠ” ì¸í„°í˜ì´ìŠ¤ëŠ” ì„¤ì •ê°’ ë”± í•˜ë‚˜ë§Œ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.

í•„ìš”í•œ ì†ì„±ë§Œ ë½‘ì•„ë‚´ ì“°ë¼ëŠ” ê²ƒ ì´ìƒì˜ ë¬´ì–¸ê°€ë¥¼ ì´í•´í•˜ëŠ” ê²ƒì´ ì•± ìš´ì˜ì´ë‚˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©ì— í•„ìˆ˜ì ì¸ ê²ƒë„ ì•„ë‹™ë‹ˆë‹¤. ìƒë‹¹í•œ ì—£ì§€ì¼€ì´ìŠ¤ë¼ë„ ê·¸ëŸ´ í•„ìš”ê°€ ì—†ì„ ê²ƒ ê°™ì€ ëŠë‚Œì´ ë“œë„¤ìš”.

ìš”ëŸ° íŠ¹ì„±ì˜ ê¸°ëŠ¥ë“¤ì„ ì˜ íŒŒì•…í•´ì„œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì•ˆìœ¼ë¡œ ê¹”ë”í•˜ê²Œ ê°€ì ¸ì˜¤ëŠ” ê²ƒì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„ ê´€ì ì˜ ë¯¸ë•ì´ ì•„ë‹Œê°€... í•˜ëŠ” ìƒê°ì´ ë“­ë‹ˆë‹¤.

<br/>


> - If you useÂ [object rest destructuring](https://github.com/tc39/proposal-object-rest-spread/blob/6ee4ce3cdda246746fc46fb149bb8b43c28e704d/Rest.md), you are effectively observing all fields. Normal destructuring is fine, just don't do this:

ì „ê°œ ì—°ì‚°ìë¡œ ë””ìŠ¤íŠ¸ëŸ­ì³ë§ì„ í•˜ë©´ tracked queryì˜ íš¨ê³¼ê°€ ì—†ì–´ì§„ë‹¤ê³  í•©ë‹ˆë‹¤.

# [4. Status Checks in React Query](https://tkdodo.eu/blog/status-checks-in-react-query)

> - `success`: Your query was successful, and you haveÂ `data`Â for it
> - `error`: Your query did not work, and anÂ `error`Â is set
> - `pending`: Your query has no data

`status`ì— ëŒ€í•œ ì„¤ëª…ì…ë‹ˆë‹¤. v4ë¶€í„° ë°”ë€Œì—ˆë˜ [`status` ì™€ `fetchStatus` ì˜ ë¶„í™”ë¡œ ì„¤ëª…í•˜ê¸° ì¢‹ì•„ì§„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.](https://maxkim-j.github.io/posts/tanstack-query-v4-preview#the-idle-state-has-been-removed) `status`ëŠ” `data`ì˜ ìœ ë¬´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•˜ê¸°ì— ë©˜íƒˆ ëª¨ë¸ì´ ë‹¨ìˆœí•©ë‹ˆë‹¤. v5ë¶€í„°ëŠ” `loading`ì´ `pending`ìœ¼ë¡œ ì´ë¦„ì´ ë°”ë€Œì—ˆìŠµë‹ˆë‹¤. ì£¼ë¡œ pendingì´ ë°ì´í„°ê°€ ì—†ìŒì„ ë” ì˜ ë‚˜íƒ€ë‚´ëŠ” ë„¤ì´ë°ì´ë¼ëŠ” [ì´ìœ ë¼ì„œ ê·¸ëŸ° ë“¯ í•©ë‹ˆë‹¤.](https://github.com/TanStack/query/discussions/4252) promiseì˜ pending ìƒíƒœë¥¼ ìƒê°í•´ë³´ë©´ ë§ì´ ë©ë‹ˆë‹¤.

<br/>

> This is even more relevant when we take into account that React Query will retry failed queries three times per default with exponential backoff, so it might take a couple of seconds until the stale data is replaced with the error screen. If you also have no background fetching indicator, this can be really perplexing. This is why I usually check for data-availability first:

í˜ì¹˜ ì‹¤íŒ¨ì‹œ `retry`ëŠ” 3ë²ˆì´ ê¸°ë³¸ê°’ì´ë¯€ë¡œ ì—ëŸ¬ ë°œìƒì‹œ ì—ëŸ¬ ë·°ë¥¼ ë„ìš´ë‹¤ë©´ ì—ëŸ¬ë¥¼ í™”ë©´ì—ì„œ ì•Œ ìˆ˜ ìˆëŠ” ì‹œì ì´ ê½¤ë‚˜ ëŠ¦ì„ ìˆ˜ ë°–ì— ì—†ìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ ì—ëŸ¬ë‚˜ ë¡œë”© ìƒíƒœë³´ë‹¤ ë°ì´í„°ê°€ availableí•œì§€ë¥¼ ë¨¼ì € ì•Œì•„ë‚´ì„œ ë¶„ê¸°ë¥¼ í•˜ëŠ”ê²Œ ë” ì¢‹ì€ í”„ë™í‹°ìŠ¤ë¼ê³  ì´ì•¼ê¸°í•˜ëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤.

ì œì‹œëœ ì˜ˆì œì²˜ëŸ¼ í•˜ë©´ ë¦¬í˜ì¹˜ì‹œ ì—ëŸ¬ ìœ ë¬´ì— ìƒê´€ì—†ì´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ë¬´ì¡°ê±´ ê·¸ ë°ì´í„°ë¥¼ ë³´ì—¬ì¤„ ê²ƒì…ë‹ˆë‹¤.

```ts
// data-first
const todos = useTodos();

if (todos.data) {
  return <div>{todos.data.map(renderTodo)}</div>;
}

if (todos.error) {
  return 'An error has occurred: ' + todos.error.message;
}

return 'Loading...';
```

# [5. Testing React Query](https://tkdodo.eu/blog/testing-react-query)

ë°±ì—”ë“œ APIë¥¼ ëª¨í‚¹í•  ìˆ˜ ìˆëŠ” ì¢‹ì€ ë°©ì‹ì„ ì„¤ëª…í•˜ê³  ê·¸ ë‹¤ìŒì— RQì— í•œì •ëœ ë¶€ë¶„ì„ ì„¤ëª…í•˜ëŠ” ê¸€ ì „ê°œ ë°©ì‹ì´ ëª…í™•í•´ì„œ ì¢‹ì•˜ìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  í…ŒìŠ¤íŠ¸ ê¿€íŒë“¤ì´ ìˆì–´ìš”.

<br/>

> It's one of the most common "gotchas" with React Query and testing: The library defaults to three retries with exponential backoff, which means that your tests are likely to timeout if you want to test an erroneous query. The easiest way to turn retries off is, again, via theÂ `QueryClientProvider`.

í…ŒìŠ¤íŠ¸ìš© `QueryClient` ëŠ” `retry` ì˜µì…˜ì„ ë„ìëŠ” ë§ì…ë‹ˆë‹¤.

<br/>

> The best advice I can give you for this problem is: Don't set these options onÂ `useQuery`Â directly. Try to use and override the defaults as much as possible, and if you really need to change something for specific queries, useÂ [queryClient.setQueryDefaults](https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults).

í…ŒìŠ¤íŠ¸ì˜ ìƒí™©ì— ë§ê²Œ íŠ¹ì • queryì˜ ì˜µì…˜ì„ ë°”ê¿”ì¤„ ìˆ˜ ìˆëŠ” APIì¸ `setQueryDefaults` ê°€ ìˆìŠµë‹ˆë‹¤. ì´ê±´ í…ŒìŠ¤íŠ¸ê°€ ì•„ë‹Œ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë°”ë¡œ ì‚¬ìš©í•˜ë©´ ì„¤ì •ê°’ì´ ì–´ë””ì„œ ë“¤ì–´ì™”ëŠ”ì§€ ëª¨ë¥´ê²Œ ë˜ì„œ ì‘ì—…ìì˜ ë‡Œì •ì§€ë¥¼ ìœ ë°œí•  ìˆ˜ë„ ìˆì„ ê²ƒ ê°™ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.

<br/>

> Since React Query is async by nature, when running the hook, you won't immediately get a result. It usually will be in loading state and without data to check

ë‹¹ì—°í•œ ì´ì•¼ê¸°ì§€ë§Œ ë¹„ë™ê¸°ë¡œ í…ŒìŠ¤íŠ¸ ê²°ê³¼ê°’ì„ ê¸°ëŒ€í•´ì•¼ í•œë‹¤ê³  í•©ë‹ˆë‹¤.

# [6. React Query and TypeScript](https://tkdodo.eu/blog/react-query-and-type-script)

> If you (like me) like to keep your api layer separated from your queries, you'll need to add type definitions anyways to avoidÂ *implicit any*, so React Query can infer the rest:

> Since React Query is not in charge of the function that returns the Promise, it also can't know what type of errors it might produce. SoÂ `unknown`Â is correct.

íƒ€ì… ì¶”ë¡ ì„ ìµœëŒ€í•œ ì´ìš©í•˜ë ¤ë©´ `queryFn`ì— ë“¤ì–´ê°€ëŠ” í•¨ìˆ˜ì— ë¦¬í„´ íƒ€ì…ì„ ì£¼ê³ , ì—ëŸ¬ íƒ€ì…ì€ ì œë„¤ë¦­ì„ ì£¼ì§€ ì•Šìœ¼ë©´ íƒ€ì…ì„ ì•Œ ìˆ˜ ì—†ìœ¼ë‹ˆ(`unknown`) ì§ì ‘ í•¸ë“¤í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

<br/>

> It will further help TypeScript to narrow types when using the status field or one of the status booleans, which it cannot do if you use destructuring:

`useQuery` ì˜ ë¦¬í„´ê°’ì€ ì„¤ì •ê°’ì— ë”°ë¼ ì¶”ë¡ ë˜ë‹ˆ ë””ìŠ¤íŠ¸ëŸ­ì³ë§ ì—†ì´ ì‚¬ìš©í•˜ëŠ”ê²Œ íƒ€ì… ì¶”ë¡ ì—ëŠ” ë” ì´ì ì´ ìˆìŠµë‹ˆë‹¤. ê·¼ë° í•„ìš”í•œ í”„ë¡œí¼í‹°ë§Œ ë””ìŠ¤íŠ¸ëŸ­ì³ë§ í•´ì•¼ ì˜ ì‘ë™í•œë‹¤ëŠ” tracked query ìª½ ë‚´ìš©ì´ë‘ ì¢€ ìƒì¶©ë˜ëŠ”ê±° ê°™ë„¤ìš”.

# [7. Using WebSockets with React Query](https://tkdodo.eu/blog/using-web-sockets-with-react-query)

> React Query doesn't have anything built-in specifically for WebSockets. That doesn't mean that WebSockets are not supported or that they don't work well with the library. It's just that React Query isÂ *very*Â agnostic when it comes to how you fetch your data: All it needs is a resolved or rejectedÂ `Promise`Â to work - the rest is up to you.

React Queryê°€ ëª…ì‹œì ìœ¼ë¡œ ì›¹ì†Œì¼“ì„ ì§€ì›í•˜ê¸°ìœ„í•œ íŠ¹ì • êµ¬í˜„ì„ ê°€ì§€ê³  ìˆì§€ ì•ŠìŒì„ ë§í•˜ëŠ”ë°, promise ê¸°ë°˜ìœ¼ë¡œë§Œ ë™ì‘ì‹œì¼œì£¼ë©´ ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì‚¬ì‹¤ ì´ëŸ° ì»¨ì…‰ ë•Œë¬¸ì— ë°ì´í„°ë¥¼ ì–´ë””ì—ì„œ ì–´ë–»ê²Œ ë°›ì•„ì˜¤ë“  ìƒê´€ì´ ì—†ê² ì£ . ìš”ê±¸ ì§šì–´ì¤€ê²Œ ì¢‹ì•˜ìŠµë‹ˆë‹¤.

<br/>

> This goal overlaps a lot with WebSockets, which update your data in real-time. Why would I need to refetch at all if I just manuallyÂ *invalidated*Â because the server just told me to do so via a dedicated message?

ì›¹ ì†Œì¼“ì€ ì´ë²¤íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ëª…ì‹œì ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì—…ë°ì´íŠ¸, invalidateí•˜ê¸° ë•Œë¬¸ì— ì‹œê°„ì— ë”°ë¼ staleí•´ì§ì„ ìƒì •í•  í•„ìš”ê°€ ì—†ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ `staleTime`ì„ `Inifinity`ë¡œ ì¡ì•„ë„ ê´œì°®ì„ ìˆ˜ ìˆë‹¤ëŠ” ë§ì´ ë˜ê² ìŠµë‹ˆë‹¤.

# [8. Effective React Query Keys](https://tkdodo.eu/blog/effective-react-query-keys)

> If you have someÂ *state*Â that changes your data, all you need to do is to put it in the Query Key, because React Query will trigger a refetch automatically whenever the key changes. So when you want to apply your filters, just change yourÂ *client state*:

`refetch`ë¥¼ í•¸ë“¤ëŸ¬ì— ë„£ì–´ì„œ í˜ì¹˜í•˜ë ¤ê³  í•˜ì§€ ë§ê³ , `queryKey`ë¥¼ ë°”ê¿” í˜ì¹˜ê°€ ë‹¤ì‹œ ì´ë£¨ì–´ì§€ë„ë¡ í•˜ë¼ëŠ” ë§ì¸ë°ìš”. `refetch`ëŠ” íŒŒë¼ë¯¸í„°ë¥¼ ë°”ê¿”ì„œ ë‹¤ì‹œ ìš”ì²­í•˜ë ¤ê³  í•  ë•Œ ì“°ë ¤ê³  ë§Œë“ ê²Œ ì•„ë‹ˆë¼ê³  í•©ë‹ˆë‹¤.

queryë¥¼ ì„ ì–¸ì ìœ¼ë¡œ ì‘ì„±í•˜ê³  ë‹¤ë£¨ëŠ”ë° í•„ìš”í•œ ì‚¬ìš© ë°©ì‹ìœ¼ë¡œ ì´í•´ë©ë‹ˆë‹¤. [Treat the query key like a dependency array](https://tkdodo.eu/blog/practical-react-query#treat-the-query-key-like-a-dependency-array) ì—ì„œ ì´ì•¼ê¸° í–ˆë˜ ì„¤ëª…ê³¼ ì´ì–´ì§€ê¸°ë„ í•©ë‹ˆë‹¤.

<br/>


> Manual Interactions with the Query Cache are where the structure of your Query Keys is most important. Many of those interaction methods, likeÂ [invalidateQueries](https://react-query.tanstack.com/reference/QueryClient#queryclientinvalidatequeries)Â orÂ [setQueriesData](https://react-query.tanstack.com/reference/QueryClient#queryclientsetqueriesdata)Â supportÂ [Query Filters](https://react-query.tanstack.com/guides/filters#query-filters), which allow you to fuzzily match your Query Keys.

ëª…ì‹œì ìœ¼ë¡œ query cacheë¥¼ ì‰½ê²Œ ë‹¤ë£¨ê¸° ìœ„í•´ query filterê°€ ìˆë‹¤ëŠ”ê±´ ì˜¤ë˜ ì „ë¶€í„° ì•Œê³  ìˆì—ˆìŠµë‹ˆë‹¤.

ê·¸ëŸ°ë° ë­”ê°€ ì‹¤ì œ ê°œë°œí• ë•Œ ë§ì´ (í˜¹ì€ ì—„ë°€í•˜ê²Œ) ì¨ë³´ì§ˆ ì•Šì•˜ìŠµë‹ˆë‹¤. ì•± ë‚´ì—ì„œ `queryKey`ë¥¼ ì œëŒ€ë¡œ ê´€ë¦¬í•˜ì§€ ëª»í•˜ëŠ” ê²½ìš°, í˜¹ì€ ë­‰ëš±ê·¸ë ¤ì„œ ê·¸ëƒ¥ ì´ê²ƒì €ê²ƒ ë‹¤ invalidate ì‹œì¼°ë˜ ê²½ìš°ê°€ ìƒê°ë‚¬ìŠµë‹ˆë‹¤. ê·¸ë§Œí¼ ì‚¬ìš©ì ê²½í—˜ì„ ì €í•˜ì‹œì¼°ì„ í…ë° ë°˜ì„±ì´ ë©ë‹ˆë‹¤.

<br/>


> I have found these strategies to work best when your App becomes more complex, and they also scale quite well. You definitely don't need to do this for a Todo App ğŸ˜.

tkdodoë‹˜ì˜ ê¸°ìˆ  ê¸€ì“°ê¸°ê°€ í¸ì•ˆí•˜ë‹¤ê³  ëŠê»´ì§€ëŠ” ë¶€ë¶„ë“¤ ì¤‘ í•˜ë‚˜ëŠ”, ì´ë ‡ê²Œ íŠ¹ì • í”„ë™í‹°ìŠ¤ì— ëŒ€í•œ ì „ì œë¥¼ ì•„ì£¼ ì˜ ì§šê³  ë„˜ì–´ê°€ëŠ” ë¶€ë¶„ì´ ë§ì•„ì„œì¸ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

<br/>

> Yes, Query Keys can be a string, too, but to keep things unified, I like to always use Arrays. React Query will internally convert them to an Array anyhow, so:

v4ë¡œ ë„˜ì–´ì˜¤ë©´ì„œ ë°°ì—´ `queryKey`ë§Œ ì“¸ ìˆ˜ ìˆë„ë¡ ë˜ì—ˆëŠ”ë°, stringì„ í—ˆìš©í•  ë•Œì—ë„ `queryKey`ëŠ” ë°°ì—´ë¡œ ë³€í˜•ë˜ëŠ” êµ¬ì¡°ì˜€ë‹¤ê³  í•©ë‹ˆë‹¤.

<br/>


> Structure your Query Keys fromÂ *most generic*Â toÂ *most specific*, with as many levels of granularity as you see fit in between. Here's how I would structure a todos list that allows for filterable lists as well as detail views:

```ts
['todos', 'list', { filters: 'all' }]
[('todos', 'list', { filters: 'done' })]
[('todos', 'detail', 1)]
[('todos', 'detail', 2)]
```

ì¸ì§€ì ìœ¼ë¡œë„ ë” ì¢‹ì€ ë°©ë²•ìœ¼ë¡œ ë³´ì—¬ì§€ë„¤ìš”. [ì œê³µëœ ì˜ˆì œ](https://tkdodo.eu/blog/effective-react-query-keys#structure)ë„ `queryKey`ê°€ ì´ëŸ° ì‹ìœ¼ë¡œ ì§œì§€ì§€ ì•Šì•˜ë‹¤ë©´ ë” ì„ ì–¸ì ìœ¼ë¡œ ë³´ì´ì§€ ì•Šì•˜ì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

<br/>


> That's why I recommend one Query Key factory per feature. It's just a simple object with entries and functions that will produce query keys, which you can then use in your custom hooks. For the above example structure, it would look something like this:

```ts
const todoKeys = {
  all: ['todos'] as const,
  lists: () => [...todoKeys.all, 'list'] as const,
  list: (filters: string) => [...todoKeys.lists(), { filters }] as const,
  details: () => [...todoKeys.all, 'detail'] as const,
  detail: (id: number) => [...todoKeys.details(), id] as const,
};
```

ë°ì´í„°ì— íŠ¹ì„±ì— ë§ê²Œ `queryKey` íŒ©í† ë¦¬ë¥¼ ë§Œë“¤ë¼ëŠ” ë§ì¸ë° ì¢‹ì€ ë°©ë²•ì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤. íŠ¹íˆ ì»¤ë‹¤ë€ í”„ë¡œì íŠ¸ì˜ ê²½ìš°ì—ëŠ” ë”ë”ìš± ê·¸ëŸ´ ê²ƒ ê°™ì•„ìš”.

ê³ê°€ì§€ ì´ì•¼ê¸°ì¸ë° `queryKey` ë¥¼ ì‹¤ë¬´ì—ì„œëŠ” URL ì—”ë“œí¬ì¸íŠ¸ì™€ request body ê°™ì€ ê²ƒë“¤ì„ ìë™ìœ¼ë¡œ ë„£ì–´ êµ¬ë¶„ì‹œí‚¤ëŠ” ê²½ìš°ë„ ê½¤ ìˆì—ˆëŠ”ë° ì´ê²Œ ì¢‹ì€ í”„ë™í‹°ìŠ¤ì¼ê¹Œ ìƒê°í–ˆë˜ ì ì´ ìˆì—ˆìŠµë‹ˆë‹¤.

`queryKey` ë¥¼ ì„œë²„ì—ì„œ ë°›ì•„ì˜¨ ì •ë³´ë¥¼ í† ëŒ€ë¡œ, ì–´ëŠì •ë„ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì¡°ì •í•˜ê³  ì´í•´í•  ìˆ˜ ìˆëŠ” ê°œë…ìœ¼ë¡œ ì‘ì„±í•´ì•¼ í•  ê²ƒì…ë‹ˆë‹¤. ê·¸ë˜ì•¼ ë‹¤ë£¨ê¸°ê°€ ë” ì‰½ê³ , ë°ì´í„°ë¥¼ í´ë¼ì´ì–¸íŠ¸ ìœ„ì£¼ë¡œ ë‹¤ë£° ìˆ˜ ìˆëŠ” ë ˆì´ì–´ê°€ ë§Œë“¤ì–´ì§ˆ ìˆ˜ ìˆëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤.

queryë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ api ìš”ì²­í–ˆë˜ URLì„ ë– ì˜¬ë ¤ì•¼ í•œë‹¤ê±°ë‚˜... í•˜ëŠ” í”„ë™í‹°ìŠ¤ëŠ” ë‡Œì •ì§€ë¥¼ ìœ ë°œí•˜ê¸°ê°€ ì‰¬ìš°ë‹ˆ, ì„œë²„ì˜ ì •ë³´ë¥¼ í† ëŒ€ë¡œ ë§Œë“¤ì–´ì§„ `queryKey`ë¥¼ íŒ©í† ë¦¬ë¡œ ë§Œë“¤ê³  ì‰½ê²Œ ê°€ì ¸ë‹¤ ì“¸ ìˆ˜ ìˆëŠ” í˜•íƒœëŠ” ì¢‹ì€ ê²ƒ ê°™ìŠµë‹ˆë‹¤. íŒ©í† ë¦¬ë¥¼ ë§Œë“¤ì§€ ì•ŠëŠ”ë‹¤ë©´, ê´€ë¦¬ê°€ ìœ ìš©í•˜ê²Œë” `queryKey`ì— ë“¤ì–´ê°ˆ ê²ƒë“¤ì„ ê°„ë‹¨í•˜ê²Œ ì˜ ë§Œë“¤ì–´ ì¨ì•¼ í•˜ê² ìŠµë‹ˆë‹¤. ê²°êµ­ ì¸ì§€ì˜ ìš©ì´í•¨ ì´ì•¼ê¸°ì¸ ê²ƒ ê°™ê¸°ë„ í•˜ê³  ê·¸ë ‡ë„¤ìš”.

---

ì—­ì‹œ ì €ë§Œ ê´€ì‹¬ìˆëŠ” ì£¼ì œëŠ” ì•„ë‹ˆì—ˆëŠ”ì§€, ëŒ“ê¸€ì°½ì— ì—¬ëŸ¬ ë§¥ë½ì˜ ì§ˆë¬¸ë“¤ì´ ì´ë£¨ì–´ì§€ê³  ìˆë˜ê²Œ í¥ë¯¸ë¡œì› ìŠµë‹ˆë‹¤. ëˆˆì— ë„ë˜ ëª‡ ê°œë¥¼ ê°€ì ¸ì™€ë³´ìë©´

> if every key starts with the name of the feature, there shouldn't be any clashes unless you have features with the same name. It was rather a problem for us to have global query keys, because they can get quite large, and if you then copy-paste one line but don't change the query key prefix (it happens!), you'll get key duplications which are very hard to spot. I've been there and it took me hours to find

`queryKey` collocationí•´ë„ ì¤‘ë³µë  ìˆ˜ ìˆìœ¼ë‹ˆ ê¸€ë¡œë²Œí•˜ê²Œ ê´€ë¦¬í•˜ë©´ ì–´ë–¨ê¹Œ? í•˜ëŠ” ì§ˆë¬¸ì— ê·¸ë ‡ê²Œ í•˜ë©´ ë„ˆë¬´ ì»¤ì§€ê³  ì•Œì•„ë³´ê¸°ë„ ì–´ë ¤ì›Œì§€ë‹ˆ granualityë¥¼ ë³´ì¥í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ `queryKey`ê°€ ë§Œë“¤ì–´ì§€ëŠ”ê²Œ ì¤‘ìš”í•˜ë‹¤ëŠ” ë‹µë³€ì…ë‹ˆë‹¤.

<br/>

> query key factory concept is very useful! how about using api baseUrl (with path parameter, query parameter) to query key? ğŸ‘€

> yes, you can do that as well and then even leverage the defaultQueryFn as described here: [default query function](https://react-query.tanstack.com/guides/default-query-function)

ë¼ì´ë¸ŒëŸ¬ë¦¬ ì…ì¥ì—ì„œë„ ì„œë²„ì˜ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ `queryKey`ë¥¼ ë§Œë“œëŠ”ê²Œ ì™„ì „ ë¹„ì¶”ì²œí•˜ëŠ” í”„ë™í‹°ìŠ¤ëŠ” ì•„ë‹Œ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

# [8a. Leveraging the Query Function Context](https://tkdodo.eu/blog/leveraging-the-query-function-context)

> Don't use inline functions - leverage the Query Function Context given to you, and use a Query Key factory that produces object keys

```ts
export const useTodos = () => {
  const { state, sorting } = useTodoParams();

  // ğŸš¨ can you spot the mistake â¬‡ï¸
  return useQuery({
    queryKey: ['todos', state],
    queryFn: () => fetchTodos(state, sorting),
  });
};
```

ì—¬ëŸ¬ê°œì˜ íŒŒë¼ë¯¸í„°ê°€ í•„ìš”í•œ ë°ì´í„° ìš”ì²­ì˜ ê²½ìš° `queryFn`ì— paramì„ ê³„ì† ë„£ì–´ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ í™•ì¥ì„ ì‹œí‚¬ ìˆ˜ ìˆëŠ”ë°, ì´ë ‡ê²Œ í•˜ë©´ `queryFn`ì˜ ì¸ìì™€ `queryKey` ë°°ì—´ì„ ë™ì‹œì— ìˆ˜ì •í•´ì•¼ í•˜ë‹ˆ ë„ˆë¬´ ë§ì•„ì¡Œì„ ë•Œ ê´€ë¦¬ì— ê³ ì¶©ì´ ìƒê¸°ê³  ì‹¤ìˆ˜í•  ì—¬ì§€ê°€ ìƒê¸°ë‹ˆ `queryFunctionContext` íŒ¨í„´ì„ ì¨ë³´ë©´ ì¢‹ë‹¤ - ì •ë„ë¡œ ì´í•´ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.

<br/>

> TheÂ `QueryFunctionContext`Â is an object that is passed as argument to theÂ `queryFn`

```ts
const fetchTodos = async ({ queryKey }) => {
  // ğŸš€ we can get all params from the queryKey
  const [, state, sorting] = queryKey;
  const response = await axios.get(`todos/${state}?sorting=${sorting}`);
  return response.data;
};

export const useTodos = () => {
  const { state, sorting } = useTodoParams();

  // âœ… no need to pass parameters manually
  return useQuery({
    queryKey: ['todos', state, sorting],
    queryFn: fetchTodos,
  });
};
```

# [9. Placeholder and Initial Data in React Query](https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query)

ì—¬ê¸°ëŠ” ì˜ ëª°ëë˜ ë‚´ìš©ì´ ë§ì•„ì„œ ê·¸ëƒ¥ ê¸€ ì „ì²´ë¥¼ ìš”ì•½í–ˆìŠµë‹ˆë‹¤.

> Another way is toÂ *synchronously*Â pre-fill the cache with data that we think will potentially be right for our use-case, and for that, React Query offers two different yet similar approaches:Â [Placeholder Data](https://tanstack.com/query/latest/docs/react/guides/placeholder-query-data)Â andÂ [Initial Data](https://tanstack.com/query/latest/docs/react/guides/initial-query-data).

> As already hinted, they both provide a way to pre-fill the cache with data that we have synchronously available. It further means that if either one of these is supplied, our query will not be inÂ `loading`Â state, but will go directly toÂ `success`Â state

ì‚¬ì‹¤ `placeholderData`ë¼ëŠ”ê²Œ ìˆëŠ”ì§€ ëª°ëëŠ”ë°ìš”. `placeholderData`ì™€ `initialData`ëŠ” ì£¼ì–´ì§€ëŠ” ìˆœê°„ `loading` ìƒíƒœë¥¼ ê±´ë„ˆë›°ê³  ë°”ë¡œ `success`ë¡œ ì§í–‰í•œë‹¤ëŠ” ê³µí†µì ì´ ìˆìŠµë‹ˆë‹¤.

<br/>

> For each Query Key, there is only one cache entry. This is kinda obvious because part of what makes React Query great is the possibility to share the same data "globally" in our application.

> An observer in React Query is, broadly speaking, a subscription created for one cache entry.

`cache`ëŠ” `queryKey` ë‹¹ í•˜ë‚˜ì˜ ì§„ì…ì ë§Œì„ ê°€ì§€ê³  ìˆê³ , `observer` ëŠ” í•˜ë‚˜ì˜ `queryKey`ì— ì—¬ëŸ¬ê°œê°€ ë  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ì´ `observer`ë¼ëŠ” ê°œë…ì„ ì²˜ìŒ ì ‘í–ˆëŠ”ë°ìš”. RQì˜ ë™ì‘ë°©ì‹ ê°€ì§€ê³  ë™ë£Œë“¤ê³¼ ì´ì•¼ê¸°í•  ë•Œ queryë¥¼ ê¸°ë³¸ì ì¸ ë‹¨ìœ„ë¡œ ìƒì •í•´ì„œ ì´ì•¼ê¸°ë¥¼ ë§ì´ í–ˆìŠµë‹ˆë‹¤. queryë¥¼ hookìœ¼ë¡œ ë§ì•„ë†“ì•„ë„ "ì‰ ì™œ ì„¤ì •ê°’ì€ ë˜‘ê°™ì€ë° ì—¬ê¸°ì„œëŠ” ë™ì‘ì´ ë‹¤ë¥´ì§€" ì‹¶ì€ ê²ƒë„ ìˆì—ˆìŠµë‹ˆë‹¤.

ê·¸ê²ƒì€ RQì˜ ë™ì‘ì´ queryë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ query observerë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë™ì‘í•˜ê¸° ë•Œë¬¸ì´ê² êµ¬ë‚˜ ì‹¶ë„¤ìš”. queryì™€ query observerëŠ” ë‹¤ë¦…ë‹ˆë‹¤.

<br/>

> `InitialData`Â works on cache level, whileÂ `placeholderData`Â works on observer level. This has a couple of implications:

`initialData`ëŠ” ìºì‹œ ë ˆë²¨ì—, `placeholderData`ëŠ” ì˜µì €ë²„ ë ˆë²¨ì— ì¡´ì¬í•œë‹¤ê³  ë§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ëŠ” [ì´ ë¶€ë¶„](https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query#differences)ì„ ìš”ì•½í•œ ê²ƒì…ë‹ˆë‹¤.

- **Persistence**: `initialData`ëŠ” ìºì‹œì— ì €ì¥ë˜ì§€ë§Œ `placeholderData`ëŠ” ê·¸ë ‡ì§€ ëª»í•˜ë‹¤.
- **Background refetches**: `initialData`ëŠ” `staleTime`ê³¼ ì—°ê´€ì´ ìˆì§€ë§Œ `placeholderData`ëŠ” ì—†ë‹¤.
- **Error Transitions**: `initialData` í™•ë³´ì‹œì˜ ì‹¤íŒ¨ëŠ” ì¼ë°˜ì ì¸ background query errorì²˜ëŸ¼ ì²˜ë¦¬ë˜ì–´ ê¸°ì¡´ì˜ ìºì‹œ ë°ì´í„°ê°€ ë‚¨ì•„ìˆìœ¼ë‚˜, `placeholderData`ëŠ” ë”°ë¡œ ì—ëŸ¬ ì²˜ë¦¬ê°€ ë˜ì§€ ì•Šê³  ìºì‹œ ë°ì´í„°ëŠ” `undefined`ë¡œ ë‚¨ëŠ”ë‹¤.

<br/>

> I personally like to useÂ `initialData`Â when pre-filling a query from another query, and I useÂ `placeholderData`Â for everything else.

`initialData`ê°€ ì—¬ëŸ¬ observerë“¤ë¡œ í•˜ì—¬ê¸ˆ ê°™ì€ ë°ì´í„°ë¥¼ ê°€ì§€ê³  ìˆì„ ìˆ˜ ìˆê²Œë” "ì „íŒŒ"í•œë‹¤ê³  ì´í•´í•  ìˆ˜ë„ ìˆì–´ ë³´ì´ë„¤ìš”.

<br/>

> What do you think will happen in each situation? I've hidden the answers so that you can try to come up with them for yourselves if you want before expanding them.

ê¹¨ì•Œê°™ì§€ë§Œ ì´ëŸ° ë¶€ë¶„ë„ ê¸°ìˆ  ê´€ë ¨ ê¸€ì„ ì „ê°œí•˜ëŠ”ë° ì¢‹ì€ í¬ì¸íŠ¸ì¸ ê²ƒ ê°™ë„¤ìš”.

# [10. React Query as a State Manager](https://tkdodo.eu/blog/react-query-as-a-state-manager)

> React Query is loved by many for drastically simplifying data fetching in React applications. So it might come as a bit of a surprise if I tell you that React Query is in factÂ *NOT*Â a data fetching library.

> React Query is an async state manager. It can manage any form of asynchronous state - it is happy as long as it gets a Promise.

React QueryëŠ” Data fetching libraryê°€ ì•„ë‹ˆë¼ **Async state managerì…ë‹ˆë‹¤**. RQëŠ” ë„¤í¬ì›Œí¬ë‚˜ ë¹„ë™ê¸° ìš”ì²­ì´ ì´ë£¨ì–´ì§€ëŠ” ë ˆì´ì–´ì— ëŒ€í•´ ì•„ì£¼ ì¡°ê¸ˆë§Œ ì•Œê³  ìˆì„ ë¿ì´ê³ (offline ëª¨ë“œì™€ ê°™ì€ ë¶€ë¶„), ë°ì´í„° íŒ¨ì¹­ì€ ì‹¤ì§ˆì ìœ¼ë¡œ axiosë‚˜ kyê°™ì€ http í´ë¼ì´ì–¸íŠ¸ê°€ ë‹´ë‹¹í•©ë‹ˆë‹¤.

RQê°€ ì €ì¥í•  ìˆ˜ ìˆëŠ” ìƒíƒœê°€ Promiseë¥¼ í†µí•´ ì œê³µë˜ëŠ” ì´ìƒ, ì‚¬ì‹¤ ë°ì´í„° íŒ¨ì¹­ì´ ì´ë£¨ì–´ì§€ì§€ ì•Šì•„ë„ ì–´ë–¤ ë°ì´í„°ë“ ì§€ RQëŠ” ê°€ì§€ê³  ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ê¹Œ ì›¹ ì†Œì¼“ì˜ ì‚¬ë¡€ë¥¼ ìƒê°í•´ë³´ì•„ë„ ë§ëŠ” ë§ì´ì£ .

<br/>

> Because React Query manages async state (or, in terms of data fetching: server state), it assumes that the frontend application doesn't "own" the data. And that's totally right. If we display data on the screen that we fetch from an API, we only display a "snapshot" of that data

í´ë¼ì´ì–¸íŠ¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ë°ì´í„° í˜ì¹­ì— êµ­í•œëœ ê³ ìœ í•œ ì§€ì ë“¤ì„ ìƒíƒœê´€ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ êµ¬í˜„ì— ë°›ì•„ë“¤ì˜€ë‹¤ëŠ” ê²ƒì´, RQì™€ ê¸°ì¡´ ë¹„ë™ê¸° ë°ì´í„°ë¥¼ ì²˜ë¦¬í• ë•Œ ì¼ë˜ Reduxê°™ì€ ìƒíƒœê´€ë¦¬ ë„êµ¬ì™€ ê°€ì¥ í° ì°¨ì´ì ì¸ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

ë°ì´í„° ìš”ì†Œì˜ íŠ¹ì„±ì— ë§ê²Œ ì‹œê³„ì—´ë¡œ ë°ì´í„°ë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ë°©ì‹ì´ë¼ë˜ì§€(`staleTime`, `cacheTime`), SWRì´ë¼ëŠ” ì»¨ì…‰, Reactì˜ ìƒëª…ì£¼ê¸°ì™€ ê´€ë ¨ë˜ì–´ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ë°©ì‹ë“¤(`refetchOnMount`)ì„ ì œê³µí•˜ê³  ìˆëŠ” ê²ƒì´ ê·¸ëŸ° êµ¬í˜„ë“¤ë¡œ ìƒê°ì´ ë©ë‹ˆë‹¤.

Reduxì—ì„œëŠ” ìƒíƒœëŠ” ê·¸ëƒ¥ ìƒíƒœì¼ ë¿ì´ê³  ë¹„ë™ê¸° ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°©ì‹ì€ ë¯¸ë“¤ì›¨ì–´ ë“±ì˜ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì§ì ‘ ë§Œë“¤ì–´ì¤˜ì•¼ í–ˆì—ˆì£ .

<br/>

> The principle is that stale data is better than no data, because no data usually means a loading spinner, and this will be perceived as "slow" by users. At the same time, it will try to perform a background refetch to revalidate that data.

ì² í•™ ìì²´ê°€ SWR ê¸°ë°˜ì´ë‹ˆ ì´ë¥¼ ì œëŒ€ë¡œ ì´ìš©í•˜ê³  ì‚¬ìš©ìì—ê²Œ ë¡œë”© ì„œí´ì„ ìµœëŒ€í•œ ë³´ì´ì§€ ì•ŠëŠ” ê²ƒì´ RQë¥¼ ì œëŒ€ë¡œ ì´ìš©í•˜ëŠ” ë°©ì‹ê³¼ ê°™ë‹¤ëŠ” ìƒê°ë„ ë“­ë‹ˆë‹¤.

ì´ í¬ìŠ¤íŒ…ì—ì„œëŠ” RQëŠ” ìƒíƒœ ê´€ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‹¤! ë¼ê³  ë§í•˜ê³ ëŠ” ìˆì§€ë§Œ ìƒíƒœ ê´€ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì²˜ëŸ¼ë§Œ ì“°ê±°ë‚˜ ê¸°ëŒ€í•˜ë©´ ì•ˆ ëœë‹¤ëŠ” ìƒê°ë„ ë™ì‹œì— ë“œëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤. ìš” ë‹¨ë½ ì•„ë˜ì—ì„œ ë‚˜ì˜¤ëŠ” `smart refetches` , `staleTime` ê³¼ ê°™ì€ ê¸°ëŠ¥ ì„¤ëª…ë“¤ì´ ê·¸ëŸ° ì´ì•¼ê¸°ë¥¼ í•˜ê³  ìˆë‹¤ê³  ëŠê»´ì ¸ìš”.

<br/>

> This is mainly becauseÂ `staleTime`Â defaults toÂ *zero*, which means that every time you e.g. mount a new component instance, you will get a background refetch.

ìš”ì¦˜ì€ ì²˜ìŒ RQë¥¼ ì…‹ì—…í•  ë•Œë¶€í„° `staleTime` ì„ ê¸°ë³¸ `Inifinity` ë¡œ ë†“ê³  ì“°ë©´ ì–´ë–¨ê¹Œ... í•˜ëŠ” ìƒê°ì´ ì¢€ ë“œëŠ”ê²Œ ê²°êµ­ defaultë¡œ ì„¤ì •ëœ 0ì€ ê°€ì¥ ê¸°ë³¸ì ì¸ ìƒí™©ì„ ìƒì •í•˜ê³  ìˆê³ , ìµœëŒ€í•œ ë§ì€ í˜ì¹­ì„ ë§Œë“¤ì–´ë‚´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

ìµœëŒ€í•œ ì˜¤ë˜ freshí•œ ìƒíƒœë¡œ ìœ ì§€í•˜ê²Œ í•œ ë‹¤ìŒ í•„ìš”í•œ ì‚¬ìš©ì²˜ì— ëª…ì‹œì ì¸ ì„¤ì •ê°’ìœ¼ë¡œ refetch, Invalidationì„ ë§Œë“¤ì–´ë‚´ëŠ” ê²ƒì´ ë” ìµœì ì ì„ ì°¾ê¸° ì‰¬ìš´ í”„ë™í‹°ìŠ¤ë¡œ ìƒê°ì´ ë“¤ê¸´ í•©ë‹ˆë‹¤. í•´ë³´ì§„ ì•Šì•„ì„œ ì§ì‘ë§Œìœ¼ë¡œ ë§í•˜ëŠ” ê±°ê¸´ í•˜ì§€ë§Œìš”.

<br/>

> What's going on here, I just fetched my data 2 seconds ago, why is there another network request happening? This is insane!

> As long as data is fresh, it will always come from the cache only. You will not see a network request for fresh data, no matter how often you want to retrieve it.

ê°™ì€ `queryKey`ë¥¼ ê°€ì§„ queryë¥¼ ë‹¤ë¥¸ ì˜µì…˜ ì—†ì´ 2ê°œë¥¼ ì—°ë‹¬ì•„ React ì»´í¬ë„ŒíŠ¸ ì•ˆì—ì„œ í˜¸ì¶œí•˜ë©´ í˜ì¹­ë„ 2ë²ˆ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤. ë°ì´í„°ê°€ freshí•œ ìƒíƒœë¡œ ë‚¨ì•„ìˆì–´ì•¼ í˜ì¹­ì´ ì¼ì–´ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

<br/>

> That changed a lot when hooks came around. You can nowÂ `useContext`,Â `useQuery`Â orÂ `useSelector`Â (if you're using redux) everywhere, and thus inject dependencies into your component. You can argue that doing so makes your component more coupled. You can also say that it's now more independent because you can move it around freely in your app, and it will just work on its own.

ì €ëŠ” ê°œì¸ì ìœ¼ë¡œ React Hooksê°€ DIì˜ ìˆ˜ë‹¨ì´ë¼ê³  ë§í•˜ê¸°ì—ëŠ” ë„ˆë¬´ ë§ì€ ê²ƒë“¤ì´ ê²°í•©ë˜ê²Œë” ë¡œì§ì´ ì§œì§„ë‹¤ê³  ìƒê°í•´ì„œ ê·¸ë ‡ê²Œ ìƒê°í•˜ì§„ ì•Šì•„ìš”. í•˜ì§€ë§Œ ë˜ ì´ ê¸€ì—ì„œ íŠ¸ë ˆì´ë“œ ì˜¤í”„ë¼ê³  ë§í•œ ê²ƒì¸, DIë¥¼ propsë¡œ í•˜ëŠ”ê²Œ ë„ˆë¬´ ì‰½ì§€ ì•Šë‹¤ ë¼ê³  í•˜ëŠ” ê²ƒë„ ë™ì˜ëŠ” ë©ë‹ˆë‹¤.

# [11. React Query Error Handling](https://tkdodo.eu/blog/react-query-error-handling)

> You see, theÂ `onError`Â callback onÂ `useQuery`Â is called for everyÂ `Observer`, which means if you callÂ `useTodos`Â twice in your application, you will get two error toasts, even though only one network request fails.

ì—ëŸ¬ë„ observer ë‹¨ìœ„ë¡œ ì²˜ë¦¬ë˜ê¸° ë•Œë¬¸ì—, onError ì½œë°±ë„ observerì˜ ê°œìˆ˜ë§Œí¼ í˜¸ì¶œë©ë‹ˆë‹¤.

<br/>

> The global callbacks need to be provided when you create theÂ `QueryCache`, which happens implicitly when you create aÂ `new QueryClient`, but you can also customize that:

ì „ì—­ì ì¸ í˜•íƒœì˜ ì—ëŸ¬ ì²˜ë¦¬ëŠ” `queryClient` ë‹¨ì—ì„œ, ì§€ì—­ì ì¸ í˜•íƒœì˜ ì—ëŸ¬ ì²˜ë¦¬ëŠ” `ErrorBoundary` ì— ì²˜ë¦¬ ë  ê²ƒì„ ê¸°ëŒ€í•˜ê³  ê°œë³„ queryì—ì„œ í•˜ë©´ ë˜ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.

ìš”ëŸ° ì›ì¹™ì„ ì¢€ ë” ì˜ ì§€í‚¬ ìˆ˜ ìˆê²Œ ë£° ê°™ì€ê²Œ í•„ìš”í•˜ê±°ë‚˜, ì—ëŸ¬ í† ìŠ¤íŠ¸ ì²˜ë¦¬ë¥¼ ì¢€ ì˜ í•  ìˆ˜ ìˆëŠ” ì„¤ê³„ê°€ í•„ìš”í•˜ë‹¤ê³  ëŠê»´ì§‘ë‹ˆë‹¤. ì—ëŸ¬ í† ìŠ¤íŠ¸ì¸ë° ì „ì—­ì—ì„œ ëœ¨ëŠ” ê±°ë‘ ì¢€ ë‹¤ë¥¸ ê±¸ ë„ìš°ê³  ì‹¶ì€ ë‹ˆì¦ˆê°™ì€ê²Œ ìƒê¸¸ìˆ˜ë„ ìˆì–´ì„œìš”.

(ë)
