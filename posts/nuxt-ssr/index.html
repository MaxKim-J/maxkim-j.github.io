<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="twitter:creator" content="@max_kim_dev" data-gatsby-head="true"/><meta name="twitter:image" content="https://maxkim-j.github.io/thumbnail.png" data-gatsby-head="true"/><meta name="twitter:description" content="pre-rendering과 hydration" data-gatsby-head="true"/><meta name="twitter:title" content="김맥스 블로그 | Nuxt로 살펴보는 서버사이드 렌더링의 핵심" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta name="image" content="https://maxkim-j.github.io/thumbnail.png" data-gatsby-head="true"/><meta name="description" content="pre-rendering과 hydration" data-gatsby-head="true"/><meta name="generator" content="Gatsby 4.19.2"/><style data-href="/styles.ffbc937d81cd1f5b5a7f.css" data-identity="gatsby-global-css">@import url(https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.5/dist/web/static/pretendard-dynamic-subset.css);body[data-theme=light] *{color:#000}body[data-theme=light] p{color:"$black"}body[data-theme=light] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#f5f5f5;--deckgo-highlight-code-carbon-color:#202020;--deckgo-highlight-code-token-atrule:#a626a4;--deckgo-highlight-code-token-comment:#65737e;--deckgo-highlight-code-token-comment-rgb:#65737e;--deckgo-highlight-code-token-function:#ac4142;--deckgo-highlight-code-token-operator:#202020;--deckgo-highlight-code-token-property:#ac4142;--deckgo-highlight-code-token-punctuation:#202020;--deckgo-highlight-code-token-regex:#f4bf75;--deckgo-highlight-code-token-selector:#90a959}body[data-theme=dark] *{background-color:#232323;color:#fff}body[data-theme=dark] a,body[data-theme=dark] a:link,body[data-theme=dark] a:visited,body[data-theme=dark] p{color:#fff}body[data-theme=dark] input[type=range]{background-color:#fff}body[data-theme=dark] input[type=range]::-webkit-slider-thumb{background-color:#fff}body[data-theme=dark] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#2b2b2b;--deckgo-highlight-code-carbon-color:#f8f8f2;--deckgo-highlight-code-token-atrule:#ffa07a;--deckgo-highlight-code-token-comment:#606060;--deckgo-highlight-code-token-comment-rgb:#d4d0ab;--deckgo-highlight-code-token-function:#00e0e0;--deckgo-highlight-code-token-operator:#abe338;--deckgo-highlight-code-token-property:#00e0e0;--deckgo-highlight-code-token-punctuation:gold;--deckgo-highlight-code-token-regex:#f8f8f2;--deckgo-highlight-code-token-selector:#f8f8f2;background-color:#2b2b2b!important}body[data-theme=aquamarine] *{background-color:#0e3e38;color:#99eae1}body[data-theme=aquamarine] a,body[data-theme=aquamarine] a:link,body[data-theme=aquamarine] a:visited,body[data-theme=aquamarine] p{color:#99eae1}body[data-theme=aquamarine] input[type=range]{background-color:#99eae1}body[data-theme=aquamarine] input[type=range]::-webkit-slider-thumb{background-color:#99eae1}body[data-theme=aquamarine] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#2b2b2b;--deckgo-highlight-code-carbon-color:#f8f8f2;--deckgo-highlight-code-token-atrule:#ffa07a;--deckgo-highlight-code-token-comment:#606060;--deckgo-highlight-code-token-comment-rgb:#d4d0ab;--deckgo-highlight-code-token-function:#00e0e0;--deckgo-highlight-code-token-operator:#abe338;--deckgo-highlight-code-token-property:#00e0e0;--deckgo-highlight-code-token-punctuation:gold;--deckgo-highlight-code-token-regex:#f8f8f2;--deckgo-highlight-code-token-selector:#f8f8f2;background-color:#2b2b2b!important}body[data-theme=lemon] *{background-color:#340e39;color:#d1ce4c}body[data-theme=lemon] a,body[data-theme=lemon] a:link,body[data-theme=lemon] a:visited,body[data-theme=lemon] p{color:#d1ce4c}body[data-theme=lemon] input[type=range]{background-color:#d1ce4c}body[data-theme=lemon] input[type=range]::-webkit-slider-thumb{background-color:#d1ce4c}body[data-theme=lemon] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#2b2b2b;--deckgo-highlight-code-carbon-color:#f8f8f2;--deckgo-highlight-code-token-atrule:#ffa07a;--deckgo-highlight-code-token-comment:#606060;--deckgo-highlight-code-token-comment-rgb:#d4d0ab;--deckgo-highlight-code-token-function:#00e0e0;--deckgo-highlight-code-token-operator:#abe338;--deckgo-highlight-code-token-property:#00e0e0;--deckgo-highlight-code-token-punctuation:gold;--deckgo-highlight-code-token-regex:#f8f8f2;--deckgo-highlight-code-token-selector:#f8f8f2;background-color:#2b2b2b!important}body[data-theme=mahogany] *{background-color:#eaedc4;color:#c9263c}body[data-theme=mahogany] a,body[data-theme=mahogany] a:link,body[data-theme=mahogany] a:visited,body[data-theme=mahogany] p{color:#c9263c}body[data-theme=mahogany] input[type=range]{background-color:#c9263c}body[data-theme=mahogany] input[type=range]::-webkit-slider-thumb{background-color:#c9263c}body[data-theme=mahogany] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#2b2b2b;--deckgo-highlight-code-carbon-color:#f8f8f2;--deckgo-highlight-code-token-atrule:#ffa07a;--deckgo-highlight-code-token-comment:#606060;--deckgo-highlight-code-token-comment-rgb:#d4d0ab;--deckgo-highlight-code-token-function:#00e0e0;--deckgo-highlight-code-token-operator:#abe338;--deckgo-highlight-code-token-property:#00e0e0;--deckgo-highlight-code-token-punctuation:gold;--deckgo-highlight-code-token-regex:#f8f8f2;--deckgo-highlight-code-token-selector:#f8f8f2;background-color:#2b2b2b!important}</style><title data-gatsby-head="true">김맥스 블로그 | Nuxt로 살펴보는 서버사이드 렌더링의 핵심</title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="dns-prefetch" href="https://www.google-analytics.com"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><style id="stitches">--sxs{--sxs:0 t-juXrtP}@media{:root,.t-juXrtP{--fonts-system:system-ui;--colors-black:#000000;--colors-dark:#232323;--colors-white:#ffffff;--colors-orange:#ffb566;--colors-turquoise:#8cffd6;--colors-pink:#ffa5e4;--fontSizes-mainTitle:30px;--fontSizes-title:28px;--fontSizes-subTitle:24px;--fontSizes-mobileTitle:20px;--fontSizes-description:14px;--fontSizes-mobileDescription:10px;--fontSizes-heading1:32px;--fontSizes-heading2:28px;--fontSizes-heading3:24px;--fontSizes-heading4:20px;--fontSizes-body1:18px;--fontSizes-body2:16px;--fontSizes-body3:14px;--fontSizes-body4:12px;--fontWeights-extraBold:700;--fontWeights-bold:550;--fontWeights-regular:500;--fontWeights-thin:300}}--sxs{--sxs:1 lhZdba fiFvXz}@media{*{font-family:Pretendard}p,body{margin:0;padding:0;font-size:var(--fontSizes-body1)}a{text-decoration:none}a:link{color:var(--colors-black)}a:visited{color:var(--colors-black)}img{width:100%;height:auto}ol{list-style-type:none;margin-block-start:0;margin-block-end:0;margin-inline-start:0;margin-inline-end:0;padding-inline-start:0}h1{font-size:var(--fontSizes-heading1);font-weight:var(--fontWeights-bold)}h2{font-size:var(--fontSizes-heading2);font-weight:var(--fontWeights-bold)}h3{font-size:var(--fontSizes-heading3);font-weight:var(--fontWeights-bold)}h4{font-size:var(--fontSizes-heading4);font-weight:var(--fontWeights-bold)}h5{font-size:var(--fontSizes-heading5);font-weight:var(--fontWeights-bold)}p{margin-bottom:24px;word-wrap:break-word;line-height:1.6;word-break:all}h1{margin-top:48px;margin-bottom:36px}h2{margin:32px 0}h3{margin:28px 0}h4{margin:24px 0}h5{margin:20px 0}p a{text-decoration:underline;text-underline-position:under}p > code{padding:2px 8px;border-radius:8px;font-size:16px}blockquote{border-left:3px solid var(--colors-black);padding-left:10px;margin:20px 0;font-style:italic}@media (max-width: 730px){deckgo-highlight-code{font-size:var(--fontSizes-body2)}}deckgo-highlight-code{--deckgo-highlight-code-white-space:pre;--deckgo-highlight-code-margin:12px 0 16px 0;--deckgo-highlight-code-scroll:none;--deckgo-highlight-code-carbon-margin:28px 0;--deckgo-highlight-code-carbon-box-shadow:none}li{line-height:1.8}li > a{text-decoration:underline;text-underline-position:under}}--sxs{--sxs:2 c-feMWly c-llJfQk c-dVNheE c-bkUmzp c-PJLV c-jMkcPK c-kdYLWQ c-iEaapN c-enMnGJ c-gHothk c-kcUpuv c-zOevm c-iDjjYv c-fVALJv c-inPSka c-hLbyMm c-kINvOu c-inYmSa c-gAHJmZ c-eqDGAL c-kxdqJo c-jPqceB}@media{.c-feMWly ol{list-style-type:decimal;margin-block-start:1em;margin-block-end:1em;margin-inline-start:2em}.c-llJfQk{width:100vw;min-height:100vh;display:flex;justify-content:center}.c-dVNheE{padding:24px 18px 0px 18px;box-sizing:border-box;width:920px}@media (max-width: 730px){.c-dVNheE{width:100%}}@media (max-width: 730px){.c-dVNheE p,.c-dVNheE ul,.c-dVNheE li{font-size:var(--fontSizes-body2)}}@media (max-width: 730px){.c-dVNheE h1{font-size:var(--fontSizes-heading2)}}@media (max-width: 730px){.c-dVNheE h2{font-size:var(--fontSizes-heading3)}}@media (max-width: 730px){.c-dVNheE h3{font-size:var(--fontSizes-heading4)}}@media (max-width: 730px){.c-dVNheE h4{font-size:body1}}.c-bkUmzp{display:flex;justify-content:space-between;margin-bottom:82px}.c-jMkcPK{font-size:var(--fontSizes-mainTitle);font-weight:var(--fontWeights-bold)}@media (max-width: 730px){.c-jMkcPK{font-size:var(--fontSizes-subTitle)}}.c-kdYLWQ{display:flex;align-items:center}.c-kdYLWQ >div{margin-left:25px}@media (max-width: 730px){.c-kdYLWQ{font-size:var(--fontSizes-body3)}}.c-iEaapN{position:relative;cursor:pointer}.c-enMnGJ{min-height:700px}.c-gHothk{margin-bottom:60px}.c-kcUpuv{margin:28px 0}.c-zOevm{font-size:var(--fontSizes-body2);margin-bottom:6px}.c-iDjjYv{font-size:var(--fontSizes-description)}.c-fVALJv{font-size:var(--fontSizes-description);margin-right:12px;text-decoration:underline}.c-inPSka{width:100%;background-color:var(--colors-black);height:1px;margin:50px 0}.c-hLbyMm{display:flex;justify-content:space-between;font-size:var(--fontSizes-description)}.c-kINvOu{display:flex;justify-content:space-between}.c-kINvOu a{margin-left:20px}.c-kINvOu a:hover{text-decoration:underline;text-underline-position:under}.c-inYmSa{margin-top:20px;display:flex;font-size:var(--fontSizes-description)}.c-inYmSa div{margin-right:18px}.c-inYmSa div:hover{text-decoration:underline;text-underline-position:under}.c-inYmSa div{cursor:pointer}.c-gAHJmZ{margin:20px 0 60px 0;display:flex;justify-content:space-between;font-size:var(--fontSizes-description)}.c-gAHJmZ a:hover{text-decoration:underline;text-underline-position:under}.c-eqDGAL a{margin-left:20px}.c-kxdqJo .utterances{max-width:none}.c-kxdqJo iframe main.timeline{padding:0}.c-jPqceB{margin-top:32px;display:flex;height:32px;align-items:center;justify-content:space-between;bottom:0;z-index:10}.c-jPqceB div{font-size:10px}.c-jPqceB a{text-decoration:underline;font-size:10px}@media (max-width: 730px){.c-jPqceB{font-size:var(--fontSizes-mobileDescription)}}}</style></head><body><script>
    const savedTheme = localStorage.getItem('maxkim-blog-theme');
    const theme = savedTheme || 'light';
    
    window.__theme = theme;
    window.__setTheme = (newTheme) => {
      document.body.setAttribute("data-theme", newTheme);
      localStorage.setItem('maxkim-blog-theme', newTheme);
    };

    window.__setTheme(theme);
  </script><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="c-llJfQk"><div class="c-dVNheE"><header><div class="c-bkUmzp"><div class="c-PJLV"><a href="/"><div class="c-jMkcPK">김맥스 블로그</div></a></div><div class="c-kdYLWQ"><div class="c-iEaapN"><div><div>color</div></div></div><div><a href="/gallery">gallery</a></div><div><a href="/about">about</a></div></div></div></header><main class="c-enMnGJ"><div class="c-gHothk"><h1 class="c-kcUpuv">Nuxt로 살펴보는 서버사이드 렌더링의 핵심</h1><div class="c-zOevm">pre-rendering과 hydration</div><div class="c-iDjjYv"><a class="c-fVALJv" href="/tags/?tag=javascript">#<!-- -->javascript</a><a class="c-fVALJv" href="/tags/?tag=vue">#<!-- -->vue</a></div></div><div class="c-feMWly"><p>Next나 Nuxt같은 SSR 라이브러리들이 이제는 널리 사용되는 것 같은데, 동작 원리를 비롯해서 프리랜더링이나 하이드레이션같은 용어를 다룬 한국어 포스팅은 잘 찾지 못했습니다. 그래서 회사에서 주로 사용하는 스택인 Nuxt를 통해 어떻게 SSR 라이브러리들이 SPA를 서버사이드 렌더링 시키는지에 대해 그 탐구의 결과를 포스팅으로 정리해보려 합니다.</p><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px">
      <a class="gatsby-resp-image-link" href="/static/0424047ea26f75e3b8ad329c656d0c70/5a190/meta.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:50%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACyElEQVQozyXP209TBwCA8fO37NHXmeiDMxG8REULVM6hhbbUc9oe7Gmhtue0pbVQCsUWQkSp2MpEvBFEostUTLwB2uiAoWI0YnSXaBPUGRLHNswSPjP38L3+kk+QZANRDlLnDmNT4zh97cjNKfb7U3gSfYSypzB6TqO15WhO5vDoWSTFwKpGqKz3sVNUqbR62SVHKJcaEUQlhKj8D9a5o1jcMYzuU5y+NcPVZ6+58nyJk7MlhufeUJgtcWJykZ5r85x88CvtY/dpH7mD2n8J89A021wtCJIcxKqGqZVDKKEMF4pPefV5jYUPKzx6ssDM67fMf1zlbmmFqff/8OCPv5ksrXBi8jnp8SKtg1eoSg6yI5GnwnkQQXLp1DdGcPgT3H3xhj+B8z/cI9A5ii/UTX5whLnFEqXlTzz8fYlHf/3LMlB8+RveRC+FkXFaOg5j8ehU/QeKsk7Nfp3B6/d5t/qZy2NX8Sl+NKdGtamGrtYUvf3DzPy8yNmJnxi4+YSHK2scvzGDlh5g/PYNjp0pUOcNY5aDCJX2JuzeQ/zyaZWJ21N4rCLehnrUWjMuaR9KTSVGIMR08TE3Zxdp6sijpgqonQUOpHJ44hnkYBxLo45ZCSJUWLwYnTmW12Byeg53KIHNF/264GxKYG9OYrJpnDk7yp3pOcr2udlcJePQ0ygtWVwt3bjCaWxaDMkTQah1h4lm8rxc+sj3QxfxGElUI4UW66KhOYbdF+XbLRX4A2EujE1gdhuYHAGsWgKLN4rFG/uaI5ymwehAUPQ0rX3nuT6/QFtfP7vFBsr3iIhODZum893Oar5Ztx5JspHK5NhYtptN201sNdVTvsfKhrJdlFXbkALtmLUoghLO0nrkHMNTz8j9WORg8giBtl4inf3EMgPstatsr3YwOnGP7NECmyskHP44evIo8Z4hoodz+A714I50Ee3O8wUE0gbUMbmq1QAAAABJRU5ErkJggg==&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="메타" title="메타" src="/static/0424047ea26f75e3b8ad329c656d0c70/5a190/meta.png" srcSet="/static/0424047ea26f75e3b8ad329c656d0c70/5a46d/meta.png 300w,/static/0424047ea26f75e3b8ad329c656d0c70/0a47e/meta.png 600w,/static/0424047ea26f75e3b8ad329c656d0c70/5a190/meta.png 800w" sizes="(max-width: 800px) 100vw, 800px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><h2 id="csr클라이언트사이드-렌더링-vs-ssr서버사이드-렌더링" style="position:relative"><a href="#csr%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81-vs-ssr%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81" aria-label="csr클라이언트사이드 렌더링 vs ssr서버사이드 렌더링 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSR(클라이언트사이드 렌더링) vs SSR(서버사이드 렌더링)</h2><p>CSR은 초기 렌더링시 내용이 없는 HTML을 받고 그 이후에는 모두 자바스크립트로 웹 페이지를 모두 작동시킵니다. 흔히 React, Vue로 만드는 SPA(Single Page Application)이 이렇게 동작하죠.</p><p>SSR은 초기 렌더링시에 내용이 존재하는, 미리 서버에서 랜더링된 HTML을 받습니다. 그 다음 자바스크립트로 웹 페이지를 완전하게 작동시킵니다. 이 포스팅에서 살펴볼 Nuxt나 React 기반의 Next등 서버사이드 렌 더링을 지원하는 라이브러리로 앱을 만들면 이처럼 동작합니다.</p><p>SSR이 필요한 가장 큰 이유는 검색 엔진 최적화입니다. 검색엔진들의 크롤링 봇들은 HTML 내용 자체를 긁어오기 때문에 처음에 내용이 빈 HTML을 받는 CSR 앱들은 검색 엔진 노출에 불리합니다.</p><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:982px">
      <a class="gatsby-resp-image-link" href="/static/dc2df1dbd9f098518ad2f8e872576373/84a90/link.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:68.33333333333333%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABiElEQVQ4y62RzWvCMBjG+1d78qQnQS9eBG+ieBARPAljbJ2dm5NtsMvo5qzWtkna2sbqPD8jgZRSdYzh4cf7mTfPm2ie5+GSaMpxXRfn/CzZXL43HZgtOo7zJ05ddFJhFEWI4xibzSb1hRUEQQDOuaxRSo/UHSm0bRvD4RD9fl/aXq+HdruNbreLwWAAXdfRarXQ6XQwGo3AGDutUCQIIbAsC41GA8ViEeVyGZVKBaVSCdVqFbVaDfV6HYVCAc1mE6ZpHr3n2ZXFSmI9QRiGErWmWl2p+3VlQf7R8x+RrZ395UugBmv57/8vaqhGCAWhDJQyEEpBmQ/m+2DSBqmVeeanfURaBnFe9PuSANrH3IK1crBae/iybIiYsBCbOAELIoQRhx/GMg6jLXjyje3ukKJinuyl1e6MCYzJFMbkEWPjAbe6gavrG7ybn3iavUAf30sepjM8v77BowEivpPD8xfw5ABtvlhJZUvblSqFOtshWLsUjscg6o7nY7Fcy1j0KEQu3u5TpYIfhFzzqeYb1RsAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="링크" title="링크" src="/static/dc2df1dbd9f098518ad2f8e872576373/84a90/link.png" srcSet="/static/dc2df1dbd9f098518ad2f8e872576373/5a46d/link.png 300w,/static/dc2df1dbd9f098518ad2f8e872576373/0a47e/link.png 600w,/static/dc2df1dbd9f098518ad2f8e872576373/84a90/link.png 982w" sizes="(max-width: 982px) 100vw, 982px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><p>URL을 어딘가에 포스팅했을때  이미지나 설명이 뜨는 링크 박스가 나타나는 거 가끔 보셨죠? 그것도 크롤링 봇이 해당 링크 HTML의 메타 태그 정보를 가져오는 건데요. CSR앱들의 메타 태그 초기 상태는 모두 똑같아서 한 웹페이지에서 메타 태그를 각각 다른 하위 페이지에 따라 다르게 만드는것도 어렵습니다. react helmet같은 라이브러리를 써도 크롤링 봇이 못 긁어오는 경우도 허다하죠.</p><p>SSR을 적용하면 초기 렌더링시에 내용이 있는 HTML에다가 메타태그까지 해당 페이지에 맞는 내용으로 커스텀할 수 있어 사이트 노출에 이점이 생깁니다.</p><h2 id="프리랜더링과-하이드레이션" style="position:relative"><a href="#%ED%94%84%EB%A6%AC%EB%9E%9C%EB%8D%94%EB%A7%81%EA%B3%BC-%ED%95%98%EC%9D%B4%EB%93%9C%EB%A0%88%EC%9D%B4%EC%85%98" aria-label="프리랜더링과 하이드레이션 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프리랜더링과 하이드레이션</h2><deckgo-highlight-code language="markdown" theme="a11y-dark">
          <code slot="code">브라우저 주소창으로 페이지 요청 =&gt;
서버에서 요청에 맞는 프리랜더링 HTML 보냄 =&gt;
브라우저에서 html받고 딸려온 자바스크립트로 하이드레이션 =&gt;
그 다음은 SPA처럼 동작 =&gt; SSR 끗!</code>
        </deckgo-highlight-code><p><strong>프리랜더링(pre-rendering)</strong>이란 React나 Vue로 만든 기존 SPA 위에서 서버에서 브라우저로 전송할 수 있도록 어느정도 완성된 HTML 파일을 만드는 동작을 의미합니다.</p><p>원래 SPA는 라우팅 역시 자바스크립트로만 이루어지는데요. SSR 라이브러리를 사용한 앱은 자바스크립트로만 라우팅하지 않고, 빌드 결과물에 작은 서버를 달아서 브라우저의 주소창으로 들어온 요청에 맞는 페이지 컴포넌트를 프리랜더링해 브라우저에 제공하는 방식으로 라우팅을 합니다.</p><p><strong>하이드레이션(hydration)</strong>이란 프리랜더링 과정을 마치고 브라우저로 전달된 HTML파일 위에 남은 자바스크립트 코드들을 실행하는 동작입니다. 하이드레이션으로 인해 SSR앱은 기존의 SPA와 동일한 동작과 반응성을 보장할 수 있게 됩니다. 용어 그대로 불완전한 HTML 파일이라는 &#x27;마른 땅&#x27;에 자바스크립트라는 &#x27;물&#x27;을 뿌리는 일입니다.</p><p>이 두 개념은 단언코 서버사이드 렌더링의 핵심입니다. 요약하면 프리랜더링은 페이지에 내용을 채워 크롤링 봇이 읽을 수 있게 해주고, 하이드레이션은 그 이후에 앱이 SPA와 똑같이 동작할 수 있도록 합니다.</p><p>여기서 <strong>SSR앱이 서버를 끼고 빌드된다는 개념</strong>은 SSR앱과 SPA의 배포 방식의 차이를 야기시킵니다. SPA의 빌드 결과물은 HTML하나랑 자바스크립트 파일 뭉치들입니다. AWS S3같은 스토리지에 빌드 결과물을 저장하고 도메인을 연결시키면 브라우저가 알아서 HTML과 JS파일들을 실행하겠죠</p><p>하지만 SSR앱은 서버를 끼고 있으니, 스토리지에 올려놓는다고 해서 브라우저가 접근해서 실행시킬 수 있는 자원이 아닙니다. 백엔드처럼 서버를 계속해서 구동할 수 있는 컴퓨팅이 필요합니다.</p><h2 id="nuxt로-살펴보는-ssr" style="position:relative"><a href="#nuxt%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-ssr" aria-label="nuxt로 살펴보는 ssr permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nuxt로 살펴보는 SSR</h2><p>이제 Nuxt가 어떤 방식으로 SSR을 구현하는지 살펴보겠습니다.</p><h3 id="3가지의-빌드-방법" style="position:relative"><a href="#3%EA%B0%80%EC%A7%80%EC%9D%98-%EB%B9%8C%EB%93%9C-%EB%B0%A9%EB%B2%95" aria-label="3가지의 빌드 방법 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3가지의 빌드 방법</h3><p><code>nuxt.config.js</code>의 build 옵션, 혹은 <code>package.json</code>에 정의된 npm 명령어를 통해 빌드 방식을 달리할 수 있습니다.</p><deckgo-highlight-code language="javascript" theme="a11y-dark">
          <code slot="code">// nuxt.config.js

export default {
mode:&#x27;spa&#x27;,
build: {
ssr:true 혹은 false,
}
}</code>
        </deckgo-highlight-code><ul><li><code>SSR : true</code> : 위에서 설명했던 방식대로 SSR앱을 빌드합니다.</li><li><code>SSR: false 혹은 mode:&#x27;spa&#x27;</code> : SPA처럼 빌드합니다. mode를 spa로 설정하면 그냥 Vue를 사용해서 만든 SPA처럼 루트 디렉토리에 dist로 빌드된 폴더가 생성됩니다. (<a href="https://ko.nuxtjs.org/guides/configuration-glossary/configuration-mode/">mode:&#x27;spa&#x27;는 deprecate 되었습니다</a>)</li><li><code>yarn generate</code>: 정적 사이트 빌드를 실행하는 스크립트 명령어입니다. pages 디렉토리의 페이지들의 그 경로 그대로 모든 html이 완성되어서 빌드됩니다.</li></ul><h3 id="ssrtrue로-빌드했을-때-동작-방식" style="position:relative"><a href="#ssrtrue%EB%A1%9C-%EB%B9%8C%EB%93%9C%ED%96%88%EC%9D%84-%EB%95%8C-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D" aria-label="ssrtrue로 빌드했을 때 동작 방식 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SSR:true로 빌드했을 때 동작 방식</h3><p>여기서 우리의 관심사는 SSR 방식의 빌드입니다. 앞에서 언급했던 방식의 서버사이드렌더링을 구현하기 위해서는 두 개의 자원이 필요합니다.</p><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:270px">
      <a class="gatsby-resp-image-link" href="/static/3dc15aa2708088f203d0438a3ac75185/01bf6/dir.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:170.74074074074073%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAE/UlEQVRIx31W2U4jRxT1ex6irAIM2L1V74vdm5d2224bm3VghmVGE0CJ8kBGURJNJKQ8jRRFivID+d4T3dtuY8Dk4aq8VJ26dc+5p6qWZQMYhgnfDyBJMjShww9a8PwAQauNdhhBN0woqgZVE2uD/qeR5tSm0z1cX9/g4OAAO7sNBuz1M3S6PeTDEcbFBIZpYbfRhKyoz4JAhG7wyICz2Ryj0QiO4zJYq91GGEWIkxTtMFx8TngDytj1PLie/ygct/yNNq55no+trTp2dnbhuh7GRYGLy0tc39zg7bt3PJ5fXOD29hb5cIgkTdHpdtcGgdYajSbXUAgdtu1gOBrh9OwMp6enODw6wtnr1xy0Cf1OC9NO51mUgB5qsqwgCFqwLJtTpj/2ZjMUkwJZlmE0HnPM9/cxmU65BK12+CyoPLbjoqYoKnTdAAFLssJsCV3HwcUNTCdGr98HKYEI295poCnJPK8iYRlKSU6NpNJoSmjKMghcEwKasNDPfezNXfhBiChOlgSQpIiEpzKq2K4R9a5uQtR3IUuUoQZZtpEXDfz6R4Iw6mKQ55jN91lCVA6SE61bC6hsbaP14QdI//4FWdOgKhoUw0DhR7ibHiPp9liXBEDHrY5cgTwHrO9CuTzB1p8foQjBgKpuIHE9XO0fIkoTdLs97gZaQFpdBXkGSLtJm3XIX37LxCg0QegwhIbPL37HdnGNaZ5hsjdn8VPHVKSsgi4Bm00JtuvCsG0GrHaUFQEvsPDz9TaCIEC3l6Hb67Pmwih+1t9LQBJ0nucs7gdADZIs4DsK7r//ijWWDXImZzQuOEzLfkTMQw0VlbuEMlWWEzQ0ZYHAU/HprgQklovJhJkmXVKWawErHSoL91hmqAg4toq7txusu0E+RD8bcKZpp8tG8WKGYRiBTEJaOTJl2PJV/P3LF5zh8cmrpZ3R2G6HkGR1fQ0Hg5wZXAWkDD1Hxcebb9hs4zhlPdKxiRw/CNZnyESoGhPy9Mieq+HD+zofj7IajsaYTPd4JCd/sYZsDDQuJiiqgKqqqCsOPkvfoxVGfIqimGD/4BCTyZQFvlY2xC7VkGRDoKv9OewZ6AwzNog4TjgrIojixU6h7AiQzLWqYdleJu5/NHF1OUKUZOzW5HusiIVlrXcbWWENPj6yBt1yEAgTnw4zvlNKYQ9Z0OtuwP8nRdVg2A4CU+D+ZMDmMByP0e9nvIhOUtWQourtpQ6p4MHiXq52FLoJw1TRTjYRRW0Uk+lS2LP5fEkOE7V/wJnTJpwhidQ0rRUdCgjDhCk0vHF2+RFAYEmScstVFxPpke4RuovKJFZr+KiXS0BLaLixtvkSI0MgUIo8H3L7kdBLZ1Kf9DJ53IIULjj9SRlqGi7VHbQWgD22ry7StIPxuOBsVy+qZeudn1+wzgi0cmbDcuBYOm7HO/B8H51+hjhNEZMfxjGStMMdRHWj+RS0tkbZEIsETJ8t2+ECm7aPKDTxz29fQypybF6eYPtkjvqbI0hhC3JTgqYb5dxF8FOEsqJnSOWHtCNfpbqNMFDx09UG/FYbnV6/zLDX45HqR6bx0AjlK4xJ4VitoaZB0y24jorvjjcQhi2+AuiYdJoojrmmBFjdMbR2yfJTcyh3NaALGXnSQByHyIdj9LOMMyO3IcDp3owfV+RA5Jm07kVA2/Xht0P4jszmW70YKOgzvSL4dz/g74ZZkvkfIoUXxb3AVLAAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="디렉토리" title="디렉토리" src="/static/3dc15aa2708088f203d0438a3ac75185/01bf6/dir.png" srcSet="/static/3dc15aa2708088f203d0438a3ac75185/01bf6/dir.png 270w" sizes="(max-width: 270px) 100vw, 270px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><p>하나는 Vue 인스턴스로 프리랜더링된 HTML을 만들어 브라우저로 쏴주는 <strong>서버 코드</strong>, 다른 하나는 클라이언트 사이드에서 기존 SPA처럼 동작할 수 있게 하는 자바스크립트 뭉치, 즉 <strong>클라이언트 코드</strong>입니다. 빌드 폴더 내부의 <code>dist</code> 폴더를 보시면 이렇게 두 폴더로 나누어져 빌드되고 있다는 것을 알 수 있는데요.</p><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1200px">
      <a class="gatsby-resp-image-link" href="/static/f71a2c0eef1bbb0ffc20efcf868d5dcc/5148a/element.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:61%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACMElEQVQoz42Sy05aURSGfQtITC2cyz43PAcE5FgidtyRL1LfQARnJTG+Qged9AGcdGwvMTFNo6CVCo3xUEDFeKmKHXzN2YAJ0TTdyZ+VNdjf+v+194SiKCwuLrK+vk6lUuFNpSLr2toapVIJz3MRjkui8Ap79iXxRAY1kSZmp3lmppiyZsY0EYlEWF1d5alzcXGJ7+eIKRpmOo+bzZNIZtAsV0oxHKZ0h5huExMOz4XDRDQaZXl5WQL69312rjpc9W9lH7Ra5HI54vE4hmGQnEnjeR7TbpKk65L2ppm2DGzLwjYEjtCGwOIA2Ppzzfv6V959+Sj7drstgYqioqoarpfkRX6ebDaLYTs4to1jmQjTQug6ptAHwFJxRQI2ugd82vrG240PbAVHnJ+eMisdKujCwPDSCMOQl1VNQ4nHh8MUVFWVGgN+/tVk50eD7d19Gr0zup3OQ2QrlcVykzJ6qBAcDtE0bUwSWCwWBxFbXZpHAYc/j2XfGUYOgc5sntTcPIWFBQqFAjNzBey0j6bp0tkYcGVl4PCkd07Q7tI5OePy+oYgaOGHO1Q1TDeFLgSmaUqJ0J0QEjIGjESjlEslft/2qR002N0/pPr9kIPGEcdBgO/70qGmDXYU/ttQo52NYKM6Frl3dcnN/R23d3f0+/cEQTB8ZQVd1x/ta6RHkcvl8pMfu9frPTj8F3DsUSYnJ3m9tESz2aRarbK3t0etVqNer7O5uUkmk5EO/wcWAv8CHCwHi1NVWNYAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="element" title="element" src="/static/f71a2c0eef1bbb0ffc20efcf868d5dcc/c1b63/element.png" srcSet="/static/f71a2c0eef1bbb0ffc20efcf868d5dcc/5a46d/element.png 300w,/static/f71a2c0eef1bbb0ffc20efcf868d5dcc/0a47e/element.png 600w,/static/f71a2c0eef1bbb0ffc20efcf868d5dcc/c1b63/element.png 1200w,/static/f71a2c0eef1bbb0ffc20efcf868d5dcc/5148a/element.png 1228w" sizes="(max-width: 1200px) 100vw, 1200px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><p><code>SSR:true</code>로 빌드한 앱을 <code>yarn start</code> 명령어를 통해 브라우저에서 실행해보았습니다. 프리랜더링된 HTML에 웹팩으로 빌드된 자바스크립트 코드가 script태그로 삽입되었음을 알 수 있습니다. 프리랜더링된 html에 SPA처럼 작동할 수 있도록 자바스크립트 코드 전부를 끼워서 같이 보내는 것이죠.</p><h3 id="vue-server-renderer" style="position:relative"><a href="#vue-server-renderer" aria-label="vue server renderer permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>vue-server-renderer</h3><p>Nuxt는 <code>vue-server-renderer</code>라는 라이브러리를 통해 뷰 인스턴스를 <a href="https://ko.nuxtjs.org/guide#%EC%84%9C%EB%B2%84-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B2%94%EC%9A%A9-ssr">서버사이드 렌더링에 적합한 구조로 만듭니다.</a> <a href="https://ssr.vuejs.org/#what-is-server-side-rendering-ssr">공식   문서</a>의 내용을 요약해보고자 합니다.</p><p>크게 이 라이브러리는 두 가지 역할을 하는데요. 첫째는 <code>renderer</code> 클래스와 내부의 <code>renderToString</code>, <code>renderToStream</code> 메소드를 통해 Vue 인스턴스를 인자로 받아서 HTML 문자열로 바꿔 렌더링할 수 있도록 돕습니다. 편리하게도 이때 Vue 인스턴스와 관련있는 css같은 asset들 역시 html에 같이 주입됩니다.</p><deckgo-highlight-code language="javascript" theme="a11y-dark">
          <code slot="code">// el 프로퍼티를 정의하지 않고 Vue 인스턴스만 생성한다는게 특징입니다
// mount는 클라이언트 사이드에서 수동으로 이루어지니깐요
const app = new Vue({
  template: `&lt;div&gt;Hello World&lt;/div&gt;`,
});

// 렌더러를 불러옵니다.
const renderer = require(&#x27;vue-server-renderer&#x27;).createRenderer();

// Vue 인스턴스를 HTML로 바꿉니다.
renderer.renderToString(app, (err, html) =&gt; {
  if (err) throw err;
  console.log(html);
  // =&gt; &lt;div data-server-rendered=&quot;true&quot;&gt;Hello World&lt;/div&gt;
});</code>
        </deckgo-highlight-code><p>둘째는 이 라이브러리와 함께 웹팩을 이용하면 프리랜더링을 하는 서버 코드와, 하이드레이션에 필요한 클라이언트 코드를 쉽게 각각 빌드할 수 있습니다. 게다가 서버, 클라이언트 두 개의 진입점을 사용해 서버와 클라이언트에서 모두 작동하는 동작(universal code)과 각자에서의 동작을 정의할 수 있습니다. Nuxt같은 서버사이드렌더링 앱을 만들 수 있는 것이죠. 관련해서 웹팩 플러그인도 있습니다.</p><p><code>vue-server-renderer</code> docs에 있는 SSR Vue앱 예제가 있는데요, 그걸 한 번 살펴보겠습니다. Nuxt의 동작방식을 간접적으로 이해할 수 있는 예제입니다.</p><h3 id="vue-server-renderer-예제" style="position:relative"><a href="#vue-server-renderer-%EC%98%88%EC%A0%9C" aria-label="vue server renderer 예제 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>vue-server-renderer 예제</h3><p>먼저 구조에 대해 말씀드리면 빌드 진입점은 <code>server-entry.js</code>, <code>client-entry.js</code> 두 개로 이루어져 있고, 이 두 모듈에서는 <code>app.js</code>의 <code>createApp</code> 함수를 참조합니다.</p><deckgo-highlight-code language="javascript" theme="a11y-dark">
          <code slot="code">// server-entry.js

import { createApp } from &#x27;./app&#x27;;

export default (context) =&gt; {
  // HTML으로 바꿀 Vue 인스턴스를 내보냅니다.
  const { app } = createApp();

  // 내보내기 전에 서버단에서만 사용하는 로직을 정의할 수 있습니다.

  return app;
};</code>
        </deckgo-highlight-code><deckgo-highlight-code language="javascript" theme="a11y-dark">
          <code slot="code">// client-entry.js

import { createApp } from &#x27;./app&#x27;;

// 마운트하기 전에 클라이언트단에서만 사용하는 로직을 정의할 수 있습니다.

const { app } = createApp();

// 클라이언트단의 js 코드는 Vue 인스턴스를 마운트시킵니다.
app.$mount(&#x27;#app&#x27;);</code>
        </deckgo-highlight-code><deckgo-highlight-code language="javascript" theme="a11y-dark">
          <code slot="code">// app.js

import Vue from &#x27;vue&#x27;;
import App from &#x27;./App.vue&#x27;;
import { createRouter } from &#x27;./router&#x27;;
import { createStore } from &#x27;./store&#x27;;
import { sync } from &#x27;vuex-router-sync&#x27;;

export function createApp() {
  // new Router()로 라우터를 정의합니다.
  // Nuxt는 pages 디렉토리를 읽어 스스로 라우터를 만듭니다.
  const router = createRouter();

  // new Vuex.Store()을 통해 저장소를 정의합니다.
  const store = createStore();

  // 라우트 정보를 store에 동기화합니다.
  sync(store, router);

  // app Vue 인스턴스에 router와 store을 주입해서 반환합니다.
  const app = new Vue({
    router,
    store,
    render: (h) =&gt; h(App),
  });

  return { app, router, store };
}</code>
        </deckgo-highlight-code><p>그리고 <code>server.js</code>에서 직접 서버를 구현합니다. 배포할때는 이 파일을 진입점으로 활용하면 되겠죠.</p><deckgo-highlight-code language="javascript" theme="a11y-dark">
          <code slot="code">// server.js
const createApp = require(&#x27;./app&#x27;);

server.get(&#x27;*&#x27;, (req, res) =&gt; {
  const context = { url: req.url };
  const app = createApp(context);

  renderer.renderToString(app, (err, html) =&gt; {
    // handle error...
    res.end(html);
  });
});</code>
        </deckgo-highlight-code><p>서버에서는 요청을 받아주는데 이때 요청한 url을 먼저 가로채서 <code>server-entry</code>에서 <code>app</code>에 맵핑된 <code>router</code>를 이용해 해당 URL로 이동하게끔 만들어줄 수 있습니다. 이때 <code>router.onready</code>이벤트 훅을 이용하면 <code>renderToString</code>이 호출되기 전에 서버에서 실행할 로직을 정의할 수 있습니다. Nuxt에서 서버에서만 작동하는 <code>asyncData</code>훅처럼요.</p><deckgo-highlight-code language="javascript" theme="a11y-dark">
          <code slot="code">// server-entry.js

import { createApp } from &#x27;./app&#x27;;

export default (context) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    const { app, router } = createApp();

    // 요청 들어온 URL로 라우팅합니다
    router.push(context.url);

    // 라우터 훅을 이 용해 서버단에서만 실행할 로직을 작성합니다.
    router.onReady(() =&gt; {
      const matchedComponents = router.getMatchedComponents();
      if (!matchedComponents.length) {
        return reject({ code: 404 });
      }

      // 이상이 없으면 라우팅된 상태의, 요청URL에 맞는 Vue 인스턴스 프로미스를 반환합니다.
      resolve(app);
    }, reject);
  });
};</code>
        </deckgo-highlight-code><p>이 예제에서는 그래서 최초로 렌더링이 이루어질 때 요청한 url에 맞는 페이지를 찾아주고, 프리렌더링 이후에 그 다음 라우팅은 모두 클라이언트 사이드에서 자바스크립트를 통해 이루어지는 것입니다. Nuxt도 그렇게 작동합니다.</p><p>라우터뿐만 아니라 Vuex 스토어 역시 서버에서부터 제어할 수 있습니다. <code>createApp</code>에서 store를 생성한 후 <code>server-entry.js</code>에서 store을 불러 <code>disaptch</code>같은 동작을 수행할 수 있습니다. 서버에서 같이 초기화된 store은 프리랜더링 과정에서 <code>JSON.stringify</code>를 사용해 <code>window.__INITIAL_STATE__</code>라는 프로퍼티에 담기게 되고 클라이언트에서는 이 정보를 그대로 받아 Vuex store을 초기에 업데이트합니다. 자세한 구현 방식은 <a href="https://ssr.vuejs.org/guide/data.html">여기</a>를 참조하시면 되겠습니다.</p><p>마지막으로 서버 코드는 router을 통해 이동한 vue 인스턴스를 <code>renderToString</code> 을 이용해 프리렌더링한 후 응답으로 전송합니다.</p><h3 id="nuxt-생명주기" style="position:relative"><a href="#nuxt-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0" aria-label="nuxt 생명주기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nuxt 생명주기</h3><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1200px">
      <a class="gatsby-resp-image-link" href="/static/502c62def1d22c8851dd9e9b51e9bae4/f36fd/nuxt-lifecycle.png" style="display:block" target="_blank" rel="noopener">
    <span class="gatsby-resp-image-background-image" style="padding-bottom:141.33333333333334%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAIAAADuuAg3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAEEElEQVQ4y32UyY7cRBjH+1V4Gg68AYg3gDNCXBAICQmJF+CCAgeEIkAi4ZAoymECPVmY9CzJdNvd3trt3a59r7KR3WF6ZkT4q+ySbP3qs//fMosAf7xpg5bPI3AUdqc5fuQ38xgO19QPPeecMibkJKU0E07pGSeiqRACtG0JaAmkEgrTEa4lN1r3w9D34wIApNs0iuM4SdZB0O6KQZmZMYYyrrUZhsEo5awbhqHq0ImfZHV3I37fSyk5F4wxpVQ/DLN+eqG1DoJwsTi9XK4IRt9fdO//srrrQYrZ6012GeZBVORZLZW5ftxsv0kpgzB8uTidHx+3bXtnkX/ww/Hd17WmvEnrroGcSydk7/orHeBhGJxzdJKzzvW9Mnay6r81sRNsjGWMOddTrhhXUunvztqP73u/esAq1dawAaRqcVGjvIG7EhQtOkT2PP/5s+ebMD730uOzdd2hj/7w3/ni/qcPPIOZDLI4rf24DNJ6nZTLIDtdbSmXb+AOgGS7RQjZfqDCOjcAaVOspe2tNoMyUmupjFRGSMW4JEwc4L2yLPP9NejywWVHUfXTaf40o0Yo1kDtnNLGTC7cdnv/A3meL72w3h6VZ19/8/Dxez9efHuc1gB7UbFOymhXQ8KvmX3T7b21khWinidd/bIQrbDaTN6/xfMR3p9nIXXGaiXLvGAIWC2LLIviGACAMfF9f7PZQIiWq9Vq5THGRlhpE6TVMswu/FQK8SJpP7t3+uWD115D010WpRnmoq7r5Wp16a2Lug2i2F+vjRlLbaaNJVxmFYiydjD6KMEf/uZ98jA4LylnFFPWsrHuERPrMNoEQd0dGm7GjCoYhlIoZ42zUKgYSyB1y4QwlmvLtebGlgC9evVqsXjpB4GwVlljezdzvVPWGOeIkLsaFC1EmDQQVwB3mFYdqiEuWkikQkxgJhATylrt7AhffYMQChFOqRBcxVUzP1+GWTn8rw5wWoJwV0e7uoHkIikevLg4D7MbaZzu+9lwgLGySQUQhP2/j53EjlW9xr3mvSK9IoNmvcSDEb1VNyIjJhYXlycnJ3XdjKQ2QYv+3oTrsjVKOMWsJJLCXjNBkWTkqmpGmFIaBoEXbFdhluRth+hX8+rdO6ef/1lsgtDz/Kyolqt1usuf/DWfHz+NouQAQ4TCKGFCd5jFWdMh+mgDfj4vnyVwVzRpXhJCGWOU0rIs87yAEDnnbtX2oIylTPJpwgKIGRdSGcIlFVIqo5S203gca9mOHfZmAELCLjdZtGv8uESYnUfp709enHjh2CpKdhgRJjBh3VTnhFIpr/Wz0gbTscUxFcrYqGzPgu227t7aULfyfCVrbUVxBNucwIaSiuKakYbTihEkBVLiNrxPfT+ReNKYdzheUoi3Rf4He78qlIo+sh0AAAAASUVORK5CYII=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="생명주기" title="생명주기" src="/static/502c62def1d22c8851dd9e9b51e9bae4/c1b63/nuxt-lifecycle.png" srcSet="/static/502c62def1d22c8851dd9e9b51e9bae4/5a46d/nuxt-lifecycle.png 300w,/static/502c62def1d22c8851dd9e9b51e9bae4/0a47e/nuxt-lifecycle.png 600w,/static/502c62def1d22c8851dd9e9b51e9bae4/c1b63/nuxt-lifecycle.png 1200w,/static/502c62def1d22c8851dd9e9b51e9bae4/d61c2/nuxt-lifecycle.png 1800w,/static/502c62def1d22c8851dd9e9b51e9bae4/97a96/nuxt-lifecycle.png 2400w,/static/502c62def1d22c8851dd9e9b51e9bae4/f36fd/nuxt-lifecycle.png 2488w" sizes="(max-width: 1200px) 100vw, 1200px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy" decoding="async"/>
  </a>
    </span></p><p>위의 예제에서 SSR앱이 서버와 클라이언트 사이드에서 다른 과정을 거쳐 렌더링을 수행한다는 것을 알 수 있을 것입니다. Nuxt도 마찬가지인데요.</p><p>Nuxt는 렌더링 과정에서 Vue 인스턴스를 계속 다루고, 각 렌더링 과정에서만 동작하는 로직들 역시 정의되어 있습니다. 따라서 Nuxt의 렌더링 과정에서는 일반적인 Vue 인스턴스의 생명주기 훅과 Nuxt에서만 찾아볼 수 있는 독특한 생명주기 훅이 섞여서 호출됩니다. 활용도가 높고 중요한 몇가지 훅들을 동작 순서대로 살펴보겠습니다.</p><ul><li><strong>middleware(클라이언트, 서버)</strong> : 클라이언트와 서버 모두 훅들이 본격적으로 호출되기 전에, 앱을 만드는 과정에서 미리 정의해놓은 미들웨어들이 먼저 동작합니다. 만약 <code>serverMiddlware</code>을 정의했다면 서버 사이드에서만 렌더링 과정에서 일반 미들웨어가 동작하기 전에 먼저 동작합니다.</li><li><strong>asyncData(서버 or 클라이언트)</strong>: 서버 혹은 클라이언트 사이드에서 생명주기 통틀어 한번씩만 호출되는 훅입니  다. Vue 인스턴스의 생명주기 이전에 먼저 데이터를 가져와서 렌더링을 하고싶은 경우에 사용합니다. 컴포넌트를 로드하기 전에 항상 호출되며, 페이지 컴포넌트의 경우에만 사용할 수 있습니다. <code>asyncData</code> 의 리턴값은 Vue 인스턴스의 <code>data()</code>와 병합됩니다.</li><li><strong>beforeCreated, created(클라이언트, 서버)</strong>: 서버에서 새로운 vue인스턴스를 생성한 뒤 이를 프리랜더링 하기 때문 Vue 인스턴스가 서버에서 만들어지는 시점에 <code>created</code>와 <code>beforeCreated</code>훅이 호출됩니다. 또한 클라이언트에서도 인스턴스를 만들고 <code>$mount</code> 메소드가 호출될 때도 따라 호출됩니다. 즉 서버와 클라이언트 사이드 양쪽에서 호출되는 훅입니다.</li><li><strong>beforeMount 이후의 훅(클라이언트)</strong>: 클라이언트 사이드에서만, 하이드레이션 이후에 <code>$mount</code> 메소드가 호출될 때 나머지 Vue 생명주기 훅들이 실행됩니다.</li></ul><p>전체적인 Nuxt의 생명주기는 <a href="https://ko.nuxtjs.org/guides/concepts/nuxt-lifecycle">여기</a>를 참고하시면 될 것 같습니다.</p><h2 id="마무리" style="position:relative"><a href="#%EB%A7%88%EB%AC%B4%EB%A6%AC" aria-label="마무리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>마무리</h2><p>동작 하나를 모두 규명하고 설명하고 싶은 욕심 때문에 긴 글이 되었지 않나 싶습니다. 사실 Nuxt의 내부를 뜯어보면서 프리랜더링 서버는 어떻게 생겼는지, <code>vue-server-renderer</code>는 어떻게 사용하고 있는지 살펴보고 싶었지만 너무 크고 복잡해서 일단 포기했습니다. 시간이 날 때 한 번 살펴보고 싶네요. 아무쪼록 SSR 라이브러리들이 동작하는 과정을 대략적으로 이해하시는데 좋은 레퍼런스가 되었으면 좋겠습니다!</p><h2 id="reference" style="position:relative"><a href="#reference" aria-label="reference permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reference</h2><ul><li><a href="https://ko.nuxtjs.org/">Nuxt Docs</a></li><li><a href="https://ssr.vuejs.org/">Vue SSR Guide</a></li><li><a href="https://medium.com/@luke_schmuke/how-we-achieved-the-best-web-performance-with-partial-hydration-20fab9c808d5">Lukas Bombach - The case of partial hydration</a></li><li><a href="https://evan-moon.github.io/2018/09/25/vue-ssr/">Evan Moon - Vue Server Side Rendering</a></li></ul><deckgo-highlight-code theme="a11y-dark">
          <code slot="code"></code>
        </deckgo-highlight-code></div><div><div class="c-inPSka"></div><div class="c-hLbyMm"><div>Written by 김맥스</div><div class="c-kINvOu"><a href="https://twitter.com/max_kim_dev">twitter</a><a href="https://github.com/MaxKim-J">github</a><a href="https://www.linkedin.com/in/%EC%A2%85%ED%98%81-%EA%B9%80-903967177/">linkedin</a></div></div><div class="c-inYmSa"><div>트위터에 공유하기</div><div>링크 복사하기</div></div><div class="c-gAHJmZ"><a href="/">글 목록으로 돌아가기</a><div class="c-eqDGAL"><a href="/posts/precedent-bot-retrospect">이전글</a><a href="/posts/async-console-log">다음글</a><a href="/posts/job-searching-retrospect">랜덤</a></div></div><div class="c-kxdqJo"></div></div></main><footer><div class="c-jPqceB"><div>김맥스 블로그ⓒ김종혁, 2022</div><div>Powered By <a href="https://www.gatsbyjs.com/">gatsby</a> /<a href="">gh-pages</a></div></div></footer></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-132859535-2', 'auto', {});
      
      
      
      
      
      }</script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/posts/nuxt-ssr/";window.___webpackCompilationHash="f7f20b5de3cdf5517536";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-f012ba4a76c3d692158a.js"],"app":["/app-7f2c0c62411c10d2f3b4.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-ce4bbd1696f109b5d64d.js"],"component---src-pages-about-index-tsx":["/component---src-pages-about-index-tsx-be1f1648f88061779477.js"],"component---src-pages-gallery-index-tsx":["/component---src-pages-gallery-index-tsx-0a570cc011ebe9b221fc.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-4842ac9a19fcb9d09583.js"],"component---src-pages-posts-mdx-slug-tsx":["/component---src-pages-posts-mdx-slug-tsx-2fb801dfa34de5e91c02.js"],"component---src-pages-tags-index-tsx":["/component---src-pages-tags-index-tsx-a9c51cc3342289b54b71.js"]};/*]]>*/</script><script src="/polyfill-f012ba4a76c3d692158a.js" nomodule=""></script><script src="/app-7f2c0c62411c10d2f3b4.js" async=""></script><script src="/framework-0ea894b592cd5d21d3c6.js" async=""></script><script src="/webpack-runtime-0d799acc24fa3839e683.js" async=""></script></body></html>