<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="twitter:creator" content="@max_kim_dev" data-gatsby-head="true"/><meta name="twitter:image" content="https://maxkim-j.github.io/thumbnail.png" data-gatsby-head="true"/><meta name="twitter:description" content="Redux, Redux Saga 시리즈 완결판" data-gatsby-head="true"/><meta name="twitter:title" content="김맥스 블로그 | 효과적인 비동기 요청 관리를 위한 Redux Store 구조" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta name="image" content="https://maxkim-j.github.io/thumbnail.png" data-gatsby-head="true"/><meta name="description" content="Redux, Redux Saga 시리즈 완결판" data-gatsby-head="true"/><meta name="generator" content="Gatsby 4.19.2"/><style data-href="/styles.10c8c1ffada55909c622.css" data-identity="gatsby-global-css">@font-face{font-family:Pretendard;font-style:normal;font-weight:500;src:url(/static/Pretendard-Regular-6090e6b5524796768e78f23519d16488.woff2) format("woff2")}@font-face{font-family:Pretendard;font-style:normal;font-weight:600;src:url(/static/Pretendard-SemiBold-7e5eaaf650b9e738991373a7f173b94a.woff2) format("woff2")}body[data-theme=light] *{color:#000}body[data-theme=light] p{color:"$black"}body[data-theme=light] p>code{background-color:#efefef}body[data-theme=light] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#f5f5f5;--deckgo-highlight-code-carbon-color:#202020;--deckgo-highlight-code-token-atrule:#a626a4;--deckgo-highlight-code-token-comment:#65737e;--deckgo-highlight-code-token-comment-rgb:#65737e;--deckgo-highlight-code-token-function:#ac4142;--deckgo-highlight-code-token-operator:#202020;--deckgo-highlight-code-token-property:#ac4142;--deckgo-highlight-code-token-punctuation:#202020;--deckgo-highlight-code-token-regex:#f4bf75;--deckgo-highlight-code-token-selector:#90a959}body[data-theme=dark] *{background-color:#232323;color:#fff}body[data-theme=dark] a,body[data-theme=dark] a:link,body[data-theme=dark] a:visited{color:#fff}body[data-theme=dark] blockquote{border-left:3px solid #fff}body[data-theme=dark] p>code{background-color:#6b6b6b}body[data-theme=dark] p{color:#fff}body[data-theme=dark] input[type=range]{background-color:#fff}body[data-theme=dark] input[type=range]::-webkit-slider-thumb{background-color:#fff}body[data-theme=dark] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#2b2b2b;--deckgo-highlight-code-carbon-color:#f8f8f2;--deckgo-highlight-code-token-atrule:#ffa07a;--deckgo-highlight-code-token-comment:#606060;--deckgo-highlight-code-token-comment-rgb:#d4d0ab;--deckgo-highlight-code-token-function:#00e0e0;--deckgo-highlight-code-token-operator:#abe338;--deckgo-highlight-code-token-property:#00e0e0;--deckgo-highlight-code-token-punctuation:gold;--deckgo-highlight-code-token-regex:#f8f8f2;--deckgo-highlight-code-token-selector:#f8f8f2;background-color:#2b2b2b!important}body[data-theme=mincho] *{background-color:#2f201b;color:#b0e8f7}body[data-theme=mincho] a,body[data-theme=mincho] a:link,body[data-theme=mincho] a:visited,body[data-theme=mincho] p{color:#b0e8f7}body[data-theme=mincho] p>code{background-color:#5e4138}body[data-theme=mincho] input[type=range]{background-color:#b0e8f7}body[data-theme=mincho] input[type=range]::-webkit-slider-thumb{background-color:#b0e8f7}body[data-theme=mincho] blockquote{border-left:3px solid #b0e8f7}body[data-theme=mincho] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#2b2b2b;--deckgo-highlight-code-carbon-color:#f8f8f2;--deckgo-highlight-code-token-atrule:#ffa07a;--deckgo-highlight-code-token-comment:#606060;--deckgo-highlight-code-token-comment-rgb:#d4d0ab;--deckgo-highlight-code-token-function:#00e0e0;--deckgo-highlight-code-token-operator:#abe338;--deckgo-highlight-code-token-property:#00e0e0;--deckgo-highlight-code-token-punctuation:gold;--deckgo-highlight-code-token-regex:#f8f8f2;--deckgo-highlight-code-token-selector:#f8f8f2;background-color:#042924!important}body[data-theme=lemon] *{background-color:#340e39;color:#d1ce4c}body[data-theme=lemon] a,body[data-theme=lemon] a:link,body[data-theme=lemon] a:visited{color:#d1ce4c}body[data-theme=lemon] blockquote{border-left:3px solid #d1ce4c}body[data-theme=lemon] p{color:#d1ce4c}body[data-theme=lemon] p>code{background-color:#7b3c83}body[data-theme=lemon] input[type=range]{background-color:#d1ce4c}body[data-theme=lemon] input[type=range]::-webkit-slider-thumb{background-color:#d1ce4c}body[data-theme=lemon] deckgo-highlight-code{--deckgo-highlight-code-carbon-background:#2b2b2b;--deckgo-highlight-code-carbon-color:#f8f8f2;--deckgo-highlight-code-token-atrule:#ffa07a;--deckgo-highlight-code-token-comment:#606060;--deckgo-highlight-code-token-comment-rgb:#d4d0ab;--deckgo-highlight-code-token-function:#00e0e0;--deckgo-highlight-code-token-operator:#abe338;--deckgo-highlight-code-token-property:#00e0e0;--deckgo-highlight-code-token-punctuation:gold;--deckgo-highlight-code-token-regex:#f8f8f2;--deckgo-highlight-code-token-selector:#f8f8f2;background-color:#2e042d!important}</style><title data-gatsby-head="true">김맥스 블로그 | 효과적인 비동기 요청 관리를 위한 Redux Store 구조</title><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="dns-prefetch" href="https://www.google-analytics.com"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><style id="stitches">--sxs{--sxs:0 t-ihqjpx}@media{:root,.t-ihqjpx{--fonts-system:system-ui;--colors-black:#000000;--colors-dark:#232323;--colors-white:#ffffff;--colors-orange:#ffb566;--colors-turquoise:#8cffd6;--colors-pink:#ffa5e4;--fontSizes-mainTitle:30px;--fontSizes-title:28px;--fontSizes-subTitle:24px;--fontSizes-mobileTitle:20px;--fontSizes-description:14px;--fontSizes-mobileDescription:10px;--fontSizes-heading1:32px;--fontSizes-heading2:28px;--fontSizes-heading3:24px;--fontSizes-heading4:20px;--fontSizes-body1:18px;--fontSizes-body2:16px;--fontSizes-body3:14px;--fontSizes-body4:12px;--fontWeights-extraBold:700;--fontWeights-bold:600;--fontWeights-regular:500;--fontWeights-thin:300}}--sxs{--sxs:1 gXKzTB fzBkpa}@media{*{font-family:Pretendard}p,body{margin:0;padding:0;font-size:var(--fontSizes-body1)}strong{font-weight:var(--fontWeights-bold)}a{text-decoration:none}a:link{color:var(--colors-black)}a:visited{color:var(--colors-black)}img{width:100%;height:auto}ol{list-style-type:none;margin-block-start:0;margin-block-end:0;margin-inline-start:0;margin-inline-end:0;padding-inline-start:0}h1{font-size:var(--fontSizes-heading1);font-weight:var(--fontWeights-bold)}h2{font-size:var(--fontSizes-heading2);font-weight:var(--fontWeights-bold)}h3{font-size:var(--fontSizes-heading3);font-weight:var(--fontWeights-bold)}h4{font-size:var(--fontSizes-heading4);font-weight:var(--fontWeights-bold)}h5{font-size:var(--fontSizes-heading5);font-weight:var(--fontWeights-bold)}p{margin-bottom:24px;word-wrap:break-word;line-height:1.6;word-break:all}h1{margin-top:48px;margin-bottom:36px}h2{margin:32px 0}h3{margin:28px 0}h4{margin:24px 0}h5{margin:20px 0}p a{text-decoration:underline;text-underline-position:under}p > code{padding:2px 8px;border-radius:8px;font-size:16px}@media (max-width: 730px){p > code{font-size:14px}}blockquote{border-left:3px solid var(--colors-black);padding-left:10px;margin:20px 0;font-style:italic}@media (max-width: 730px){deckgo-highlight-code{font-size:var(--fontSizes-body2)}}deckgo-highlight-code{--deckgo-highlight-code-white-space:pre;--deckgo-highlight-code-margin:12px 0 16px 0;--deckgo-highlight-code-scroll:none;--deckgo-highlight-code-carbon-margin:28px 0;--deckgo-highlight-code-carbon-box-shadow:none}li{line-height:1.8}li > a{text-decoration:underline;text-underline-position:under}}--sxs{--sxs:2 c-llJfQk c-dVNheE c-bkUmzp c-PJLV c-jMkcPK c-kdYLWQ c-iEaapN c-enMnGJ c-jPqceB c-feMWly c-gHothk c-kcUpuv c-zOevm c-iDjjYv c-inPSka c-hLbyMm c-kINvOu c-inYmSa c-gAHJmZ c-eqDGAL c-kxdqJo c-fVALJv}@media{.c-llJfQk{width:100vw;min-height:100vh;display:flex;justify-content:center}.c-dVNheE{padding:24px 18px 0px 18px;box-sizing:border-box;width:920px}@media (max-width: 730px){.c-dVNheE{width:100%}}@media (max-width: 730px){.c-dVNheE p,.c-dVNheE ul,.c-dVNheE li{font-size:var(--fontSizes-body2)}}@media (max-width: 730px){.c-dVNheE h1{font-size:var(--fontSizes-heading2)}}@media (max-width: 730px){.c-dVNheE h2{font-size:var(--fontSizes-heading3)}}@media (max-width: 730px){.c-dVNheE h3{font-size:var(--fontSizes-heading4)}}@media (max-width: 730px){.c-dVNheE h4{font-size:body1}}.c-bkUmzp{display:flex;justify-content:space-between;margin-bottom:82px}.c-jMkcPK{font-size:var(--fontSizes-mainTitle);font-weight:var(--fontWeights-bold)}@media (max-width: 730px){.c-jMkcPK{font-size:var(--fontSizes-subTitle)}}.c-kdYLWQ{display:flex;align-items:center}.c-kdYLWQ >div{margin-left:25px}@media (max-width: 730px){.c-kdYLWQ{font-size:var(--fontSizes-body3)}}.c-iEaapN{position:relative;cursor:pointer}.c-enMnGJ{min-height:700px}.c-jPqceB{margin-top:32px;display:flex;height:32px;align-items:center;justify-content:space-between;bottom:0;z-index:10}.c-jPqceB div{font-size:10px}.c-jPqceB a{text-decoration:underline;font-size:10px}@media (max-width: 730px){.c-jPqceB{font-size:var(--fontSizes-mobileDescription)}}.c-feMWly ol{list-style-type:decimal;margin-block-start:1em;margin-block-end:1em;margin-inline-start:2em}.c-gHothk{margin-bottom:60px}.c-kcUpuv{margin:28px 0}.c-zOevm{font-size:var(--fontSizes-body2);margin-bottom:6px}.c-iDjjYv{font-size:var(--fontSizes-description)}.c-inPSka{width:100%;background-color:var(--colors-black);height:1px;margin:50px 0}.c-hLbyMm{display:flex;justify-content:space-between;font-size:var(--fontSizes-description)}.c-kINvOu{display:flex;justify-content:space-between}.c-kINvOu a{margin-left:20px}.c-kINvOu a:hover{text-decoration:underline;text-underline-position:under}.c-inYmSa{margin-top:20px;display:flex;font-size:var(--fontSizes-description)}.c-inYmSa div{margin-right:18px}.c-inYmSa div:hover{text-decoration:underline;text-underline-position:under}.c-inYmSa div{cursor:pointer}.c-gAHJmZ{margin:20px 0 60px 0;display:flex;justify-content:space-between;font-size:var(--fontSizes-description)}.c-gAHJmZ a:hover{text-decoration:underline;text-underline-position:under}.c-eqDGAL a{margin-left:20px}.c-kxdqJo .utterances{max-width:none}.c-kxdqJo iframe main.timeline{padding:0}.c-fVALJv{font-size:var(--fontSizes-description);margin-right:12px;text-decoration:underline}}</style></head><body><script>
    const savedTheme = localStorage.getItem('maxkim-blog-theme');
    const theme = savedTheme || 'light';
    
    window.__theme = theme;
    window.__setTheme = (newTheme) => {
      document.body.setAttribute("data-theme", newTheme);
      localStorage.setItem('maxkim-blog-theme', newTheme);
    };

    window.__setTheme(theme);
  </script><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="c-llJfQk"><div class="c-dVNheE"><header><div class="c-bkUmzp"><div class="c-PJLV"><a href="/"><div class="c-jMkcPK">김맥스 블로그</div></a></div><div class="c-kdYLWQ"><div class="c-iEaapN"><div><div>color</div></div></div><div><a href="/gallery">gallery</a></div><div><a href="/about">about</a></div></div></div></header><main class="c-enMnGJ"><div class="c-gHothk"><h1 class="c-kcUpuv">효과적인 비동기 요청 관리를 위한 Redux Store 구조</h1><div class="c-zOevm">Redux, Redux Saga 시리즈 완결판</div><div class="c-iDjjYv"><a class="c-fVALJv" href="/tags/?tag=react">#<!-- -->react</a><a class="c-fVALJv" href="/tags/?tag=redux">#<!-- -->redux</a></div></div><div class="c-feMWly"><blockquote><p>이전 글 <a href="https://maxkim-j.github.io/posts/how-to-minimize-redux-saga-typing"><strong>Redux Toolkit과 자체 util 함수로 Redux+Saga 타이핑 줄이기</strong> &gt; </a>에서 이어지는 포스팅입니다!</p></blockquote><p>최근 회사 프로덕트의 비동기 요청들을 관리하는 Redux Store, Saga들의 구조를 리팩토링하는데 많은 힘을 쏟았었습니다. 개선의 포인트는 크게 2가지였는데요.</p><ol><li>Redux Toolkit과 자체 Util 함수를 사용해 Action, Saga들이 다른 보조 라이브러리 없이 일일히, 장황하게 선언된 Redux Store의 타이핑을 줄이기</li><li>효과적으로 비동기 요청 응답 데이터 값들을 저장하기 위한 Redux Store의 구조 만들기</li></ol><p>이전 포스팅에서 Redux Toolkit을 이용해 Redux Store의 타이핑을 줄이는 몇 가지 용례를 보여드린 적이 있습니다. 이번 포스팅에서는 저번 포스팅에서 소개했던 패턴을 실제 프로덕트에 적용하는 과정에서 프로덕트에 맞게끔 약간의 수정을 거쳤습니다.</p><p>이번 포스팅에서는 고민 끝에 나름의 답을 낸 효과적인 비동기 요청 관리를 위한 Redux Store의 구조와, 변경된  구조에 맞게 약간의 변화를 준 Redux Utils(reducer, saga를 만드는 factory 함수)들을 소개해보려고 합니다.</p><p>그동안 탐구해왔었던 Redux Store를 통한 비동기 요청 관리법이라는 주제에 마무리, 완결판 격인 포스팅이 될 것 같습니다.</p><h1 id="redux-store-구조-잡기" style="position:relative"><a href="#redux-store-%EA%B5%AC%EC%A1%B0-%EC%9E%A1%EA%B8%B0" aria-label="redux store 구조 잡기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redux Store 구조 잡기</h1><h2 id="기존-asyncentity의-문제점과-개선-방향" style="position:relative"><a href="#%EA%B8%B0%EC%A1%B4-asyncentity%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%EA%B0%9C%EC%84%A0-%EB%B0%A9%ED%96%A5" aria-label="기존 asyncentity의 문제점과 개선 방향 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>기존 AsyncEntity의 문제점과 개선 방향</h2><p>저번 포스트에서 store에서 한 단위의 비동기 데이터를 책임지는 프로퍼티를 AsyncEntity라고 설정했습니다. 저번 포스트에서 정의했던 AsyncEntity는 이런 식으 로 생겼습니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">export type GeneralStatus = &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;success&#x27; | &#x27;fail&#x27;;

export type AsyncEntity&lt;DataType&gt; = {
  data: DataType | null;
  status: GeneralStatus;
  error: Error | null;
};

// store의 프로퍼티 초기 상태 = AsyncEntity&lt;UserInfo&gt;
userInfo: {
  data: null,
  status: &#x27;idle&#x27;,
  error: null,
}
</code>
        </deckgo-highlight-code><p>data 프로퍼티를 data가 저장되는 하나의 source로 이용하고, 다른 프로퍼티로 가장 최근에 이루어졌던 요청의 상태와 에러 여부를 저장합니다.</p><p>또한 PUT, POST, DELETE 등의 요청에서 특정 값이 응답으로 오지 않는 경우에, data를 없애고 요청의 상태만 저장할 수 있는 타입을 따로 만들었습니다</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">export type StatusOnlyAsyncEntity = {
  status: GeneralStatus;
  error?: Error | null;
};

// store의 프로퍼티 초기 상태 = StatusOnlyAsyncEntity
putUserInfoStatus: {
  status: &#x27;idle&#x27;,
  error: null,
}</code>
        </deckgo-highlight-code><p>그렇지만 서버에 요청해 받는데이터들은 클라이언트에서 GET 요청을 할 때만 받을 수 있는 것은 아닐 수도 있습니다. POST, PUT, DELETE 등의 요청으로 직접 클라이언트에서 데이터를 수정하는 요청을 보낼 경우에도 백엔드에서 수정된 데이터 자체를 반환해줄 때가 있습니다.</p><p>위에서 보여드린 타입들만 사용해서는 사실상 같이 묶일 수 있는 요청 상태값을 스토어의 다른 프로퍼티에서 관리해야 하는데 꽤 비효율적으로 느껴집니다. store 프로퍼티들의 응집도가 떨어지는 느낌도 있고요.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">// 요청별로 다른 상태와 값 을 가질때
userInfo: {
  data: UserInfo,
  status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;success&#x27; | &#x27;fail&#x27;,
  error: Error,
},
userInfoPutStatus: {
  // PUT 요청 성공시 userInfo.data를 수정해야함 =&gt; 낮은 응집도
  status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;success&#x27; | &#x27;fail&#x27;,
  error: Error,
}
userInfoDeleteStatus: {
  // DELETE 요청 성공시 userInfo.data를 수정해야함 =&gt; 낮은 응집도
  status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;success&#x27; | &#x27;fail&#x27;,
  error: Error,
}
</code>
        </deckgo-highlight-code><p>이렇게 해보면 어떨까요? store에서는 한 단위의 데이터를 대표하는 프로퍼티를 만들고, GET, POST 등의 요청 메소드들의 상태가 모두 관리될 수 있게 만드는 겁니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">userInfo: {
  data: UserInfo,
  GET: {
    status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;success&#x27; | &#x27;fail&#x27;,
    error: Error,
  },
  PUT: {
    status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;success&#x27; | &#x27;fail&#x27;,
    error: Error,
  },
  DELETE: {
    status: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;success&#x27; | &#x27;fail&#x27;,
    error: Error,
  },
}</code>
        </deckgo-highlight-code><p>예컨데, 앱에 댓글 기능이 있어서 GET 요청 할 경우 댓글 리스트를 가져오고, PUT, POST, DELETE 요청을 했을 때는 요청이 반영된 최신의 댓글 리스트를 가져온다면 이런 스토어 구조가 서버 데이터를 관리하기 더 편할 것입니다. 데이터는 요청 메소드가 무엇이든 <strong>단 한 곳에만 저장됩니다(<code>userInfo.data</code>)</strong></p><p>이렇게 각 요청들이 균일하게 스토어에 자리잡을 수 있도록 구조를 잡으면, 뒤에서 추가적으로 설명할 Reducer의 팩토리 유틸 함수를 만들 때 응답값을 처리하는 로직도 균일하게 만들어 유틸 함수로 분리하기 편합니다.</p><h2 id="새로운-asyncentity-타입으로-store-작성" style="position:relative"><a href="#%EC%83%88%EB%A1%9C%EC%9A%B4-asyncentity-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-store-%EC%9E%91%EC%84%B1" aria-label="새로운 asyncentity 타입으로 store 작성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>새로운 AsyncEntity 타입으로 Store 작성</h2><p>먼저, 요청의 상태값을 관리하는 객체에 대한 타입을 먼저 선언합니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">export type GeneralStatus = &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;success&#x27; | &#x27;fail&#x27;;

export type AsyncEntityStatus&lt;StatusType&gt; = {
  status: StatusType;
  error?: BaseException | null;
};</code>
        </deckgo-highlight-code><p>기본적으로는 status 프로퍼티가 <code>success | fail | idle | loading</code> 이라는 기본적인 4가지 상태를 갖게 GeneralStatus type을 선언합니다.</p><p>성공, 혹은 실패의 유형이 여러가지라면 <code>success1 | success2 | fail1 | fail2 | idle | loading</code> 이런 식의 상태값이 가능할 수도 있을 것입니다. <code>AsyncEntityStatus</code>에는 제네릭으로 가질 수 있는 상태값의 타입을 넣어줄 수도 있도록 설정했습니다.</p><p>이전에 고정적이었던 AsyncEntity 프로퍼티는 잘게 분해되었습니다. 아래와 같은 타입들이 모두 모여 하나의 AsyncEntity를 만듭니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">export type AsyncEntityData&lt;DataType&gt; = {
  data: DataType | null;
};

export type AsyncEntityGetStatus&lt;GetStatus = GeneralStatus&gt; = {
  GET: CustomStatusOnlyAsyncEntity&lt;GetStatusType&gt;;
};

export type AsyncEntityPostStatus&lt;PostStatus = GeneralStatus&gt; = {
  POST: CustomStatusOnlyAsyncEntity&lt;PostStatusType&gt;;
};

export type AsyncEntityPutStatus&lt;PutStatus = GeneralStatus&gt; = {
  PUT: CustomStatusOnlyAsyncEntity&lt;PutStatusType&gt;;
};

export type AsyncEntityDeleteStatus&lt;DeleteStatus = GeneralStatus&gt; = {
  DELETE: CustomStatusOnlyAsyncEntity&lt;DeleteStatusType&gt;;
};

// Store Type
// GET, POST, PUT 하는 userInfo 데이터 - 필요한 메서드마다 자유롭게 붙일 수 있습니다
type UserInfoAsyncEntity = AsyncEntityData&lt;UserInfo&gt; &amp;
  AsyncEntityGetStatus &amp;
  AsyncEntityPostStatus &amp;
  AsyncEntityPutStatus;

type UserStore = {
  userInfo: UserInfoAsyncEntity;
};</code>
        </deckgo-highlight-code><p>데이터를 저장할 프로퍼티(AsyncEntityData)를 하나 만들고, 해당 데이터를 수정하는 메소드 이름으로 프로퍼티들을 하나씩 붙이는 방식으로 선언합니다.</p><p>이제 완성된 타입들을 사용하여 slice를 선언하는 곳에 initalState를 선언합니다.</p><p>타입값에 맞는 store의 초기값을 대입해주는데요. 초기에는 아직 데이터가 없으니 data 프로퍼티는 null로, status는 모두 idle로 맞춥니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">const initialStore: UserStore = {
  userInfo: {
    data: null,
    GET: {
      status: &#x27;idle&#x27;,
      error: null,
    },
    POST: {
      status: &#x27;idle&#x27;,
      error: null,
    },
    PUT: {
      status: &#x27;idle&#x27;,
      error: null,
    },
  },
};</code>
        </deckgo-highlight-code><p><code>AsyncEntityData</code>의 data 프로퍼티 타입은 null도 가능한데요, 데이터가 없는 상태를 명시적으로 null로 표현하기 위해서입니다. data타입에 아래와 같이 null 대입이 가능하지 않으면 문제가 생길 수 있습니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">export type AsyncEntityData&lt;DataType&gt; = {
  data: DataType;
};</code>
        </deckgo-highlight-code><p>리스폰스의 타입이 배열이라 초기값을 빈 배열로 했을 경우, 실제로 데이터가 아무것도 없어 백엔드에서 빈 배열이 날아오는 경우와 구분이 안 될 수도 있습니다. 타입이 객체일 경우에는 데이터 타입의 모든 프로퍼티들의 초기값을 일일히 정해줘야 하니 귀찮습니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">// X - 배열
const initialStore:UserStore = {
  userInfo: {
    data: [], // 데이터가 없을 때 올 수도 있는 빈배열과 구분이 안됨
    GET: {
      status: &#x27;idle&#x27;,
      error: null
    },
  ...
}

// X - 객체
const initialStore:UserStore = {
  userInfo: {
  data: {
    userName: &#x27;&#x27;,
    userAge: 0,
    ...
  }, // 빈 객체는 타입 정의에 맞지 않으니 모든 프로퍼티의 초기값을 입력해줘야 함
  GET: {
    status: &#x27;idle&#x27;,
    error: null
  },
  ...
  }
}</code>
        </deckgo-highlight-code><p>이것으로 store을 다 만들었습니다!</p><h1 id="reducer" style="position:relative"><a href="#reducer" aria-label="reducer permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reducer</h1><h2 id="reducer-factory-함수---createreducer" style="position:relative"><a href="#reducer-factory-%ED%95%A8%EC%88%98---createreducer" aria-label="reducer factory 함수   createreducer permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reducer Factory 함수 - createReducer</h2><p>제가 사용하는 redux toolkit slice의 reducer 함수를 만드는 유틸 함수는 크게 4가지입니다.</p><p>위에서 선언한 <code>GeneralStatus</code> 타입의 상태변화를 만들고, 요청 성공 시 적당한 처리를 할 수 있는 reducer 함수를 만드는 팩토리 함수들입니다. 비동기 동작이 아닌 StatusType을 쓴다면 reducer 함수를 직접 구현해야겠지만 일반적인 상황에서는 이 4가지 함수로 대부분의 상황이 커버됩니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">const createStartReducer =
  &lt;State extends { [key: string]: any }&gt;(entity: string, method: HttpMethods) =&gt;
  &lt;PayloadType&gt;() =&gt; {
    return (state: State, action: PayloadAction&lt;PayloadType&gt;) =&gt; {
      state[entity][method].status = &#x27;loading&#x27;;
    };
  };

const createSuccessReducer =
  &lt;State extends { [key: string]: any }&gt;(entity: string, method: HttpMethods) =&gt;
  &lt;PayloadType&gt;() =&gt; {
    return (state: State, action: PayloadAction&lt;PayloadType&gt;) =&gt; {
      state[entity].data = action.payload;
      state[entity][method].error = null;
      state[entity][method].status = &#x27;success&#x27;;
    };
  };

const createMethodFailReducer =
  &lt;State extends { [key: string]: any }&gt;(entity: string, method: HttpMethods) =&gt;
  &lt;PayloadType&gt;() =&gt; {
    return (state: State, action: PayloadAction&lt;PayloadType&gt;) =&gt; {
      state[entity][method].error = action.payload;
      state[entity][method].status = &#x27;fail&#x27;;
    };
  };

const createMethodStatusRestoreReducer =
  &lt;State extends { [key: string]: any }&gt;(entity: string, method: HttpMethods) =&gt;
  () =&gt; {
    return (state: State) =&gt; {
      state[entity][method].status = &#x27;idle&#x27;;
    };
  };</code>
        </deckgo-highlight-code><p>상태가 변할때마다 Store을 어떻게 수정하고 있는지 잘 파악할 수 있으시겠죠?</p><p>저번 포스팅과 다른 점이 있다면 요청이 success, fail이 나고 맨 마지막에 idle 상태로 바꾸는 restore reducer 팩토리 함수가 추가되었다는 것입니다.</p><p>프로덕트에 적용을 해보고 나서야 확실하게 알았던 부분인데요, 요청이 success 혹은 fail로 마무리가 된 이후에 다시 초기와 똑같은 idle, 유휴 상태로 돌려놔야할 필요성이 확실히 있었습니다.</p><p>GET 요청인 경우에는 마지막 상태와 상관없이 페이지에 진입할 때와 같은 상황에서 재호출이 발생하며 삽시간에 상태가 바뀌기 때문에 마지막 상태가 success든 fail이든 별 상관이 없어 보일 수 있습니다.</p><p>하지만 POST, PUT, DELETE의 경우 success, fail이 된 채로 그대로 남아있으면 다시 요청을 해야하는 상황에 놓일 때 요청을 하기 전인데도 success나 fail같은 상태가 이미 입력이 되어 있어 예상치 못한 사이드 이펙트를 유발할 가능성이 있습니다.</p><h2 id="실제-구현" style="position:relative"><a href="#%EC%8B%A4%EC%A0%9C-%EA%B5%AC%ED%98%84" aria-label="실제 구현 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>실제 구현</h2><p>유저 정보에 대한 리듀서 함수들을 만들어줍니다. store 프로퍼티의 이름과, 메소드 적당한 타입도 제네릭으로 주입해줍니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">type GetUserStartPayload = {
  userId: number;
};

const userSlice = createSlice({
  name: &#x27;user&#x27;,
  initialState,
  reducers: {
    getUserInfo: createStartReducer(&#x27;userInfo&#x27;, &#x27;GET&#x27;)&lt;GetUserStartPayload&gt;(),
    getUserInfoSuccess: createSuccessReducer(&#x27;userInfo&#x27;, &#x27;GET&#x27;)&lt;UserInfo&gt;(),
    getUserInfoFail: createFailReducer(&#x27;userInfo&#x27;, &#x27;GET&#x27;)&lt;AxiosError&gt;(),
    getUserInfoRestore: createRestoreReducer(&#x27;userInfo&#x27;, &#x27;GET&#x27;)(),
  },
});

export const userActions = userSlice.actions;</code>
        </deckgo-highlight-code><h1 id="saga" style="position:relative"><a href="#saga" aria-label="saga permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Saga</h1><p>마지막으로 실제로 API 호출이 이루어지는 사가 함수입니다.</p><h2 id="async-saga-factory-함수---createasyncsaga" style="position:relative"><a href="#async-saga-factory-%ED%95%A8%EC%88%98---createasyncsaga" aria-label="async saga factory 함수   createasyncsaga permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Async Saga Factory 함수 - createAsyncSaga</h2><p>비동기 요청을 실제로 수행하고, 결과에 따라 적당한 액션을 발행하는 Saga를 만드는 유틸 함수는 다음과 같이 생겼습니다. 제네레이터 함수를 반환하는 일종의 고차 팩토리 함수입니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">import { ActionCreatorWithPayload } from &quot;@reduxjs/toolkit&quot;;
import { AxiosResponse } from &quot;axios&quot;;

type CreateAsyncSagaOptions&lt;Start, Success&gt; = {
  fn: (requestBody: Start) =&gt; Promise&lt;AxiosResponse&lt;Success&gt;&gt;;
  sustain?: number;
};

const createAsyncSaga = &lt;Start, Success, Fail&gt;(
  success: ActionCreatorWithPayload&lt;Success&gt;,
  fail: ActionCreatorWithPayload&lt;Fail&gt;,
  { fn, sustain = 1000 }: CreateAsyncSagaOptions&lt;Start, Success&gt;
  ) =&gt; {
    return function\* (action: PayloadAction&lt;Start&gt;) {
    try {
      // 비동기 요청 함수의 인자에 맞게 Start의 action.payload 프로퍼티를 맞춰준다
      const response: AxiosResponse&lt;Success&gt; = yield call(fn, action.payload);
      yield put(success(response.data));
    } catch (error) {
      const response: AxiosResponse&lt;Fail&gt; = error;
      yield put(fail(response.data));
    } finally {
      yield delay(sustain); // success혹은 fail이후 상태 유지를 얼마나 할 것인지
      yield put(restore(undefined)); // 상태유지 시간이 지나고 나면 idle로 전환
    }
  };
};</code>
        </deckgo-highlight-code><p>인자로 success, fail, restore 액션을 받고 적절한 상황에 액션을 발행해 Saga를 호출합니다.</p><p>기본적으로는 요청에 필요한 requestBody이나 쿼리파람을 Start action의 payload로 삼아 넣어줍니다. Saga 내부에서 호출할 함수는 다음과 같이 만들어놓아야 합니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">const getUserInfo = ({ userId }: GetUserStartPayload) =&gt; {
  return axios.get(&#x27;baseurl/user&#x27;, {
    params: { userId },
  });
};</code>
        </deckgo-highlight-code><p>sustain 인자를 통해 비동기 요청 완결(success, fail)이후 결과값을 나타내는 상태를 몇 ms간 유지할것인지 설정할 수 있습니다. 요청 이후 alert를 일정 시간동안 띄운다거나 하는 동작에서 활용할 수 있습니다.</p><p>애플리케이션의 특성에 따라 다양한 인자를 설정할 수 있는데요. 가령 auth 파라미터를 설정해서 유저 인증이 필요한 API 요청인지를 표현할 수도 있겠습니다.</p><p>auth가 true일 경우 유저 인증을 위한 token을 저장하는 userReducer에 select 함수로 스토어에 진입해 tokenId를 가져오거나 하는 방식으로 활용할 수 있겠습니다.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">const createAsyncSaga = &lt;Start, Success, Fail&gt;(
    success: ActionCreatorWithPayload&lt;Success&gt;,
    fail: ActionCreatorWithPayload&lt;Fail&gt;,
    { fn, auth, sustain = 1000 }: CreateAsyncSagaOptions&lt;Start, Success&gt;,
  ) =&gt; {
    return function(action: PayloadAction&lt;Start&gt;) {
      // token을 store에 저장한다면 이런 방식으로 활용 가능
      const { tokenId } = yield select((state) =&gt; state.userReducer);
      const requestBody = [action.payload];

      if (auth) {
        requestBody.push(tokenId)
      }

      try {
        const response: AxiosResponse&lt;Success&gt; = yield call(fn, ...requestBody);
        yield put(success(response.data));
      } catch (error) {
        ...
      }
    };
};</code>
        </deckgo-highlight-code><h2 id="실제-구현-1" style="position:relative"><a href="#%EC%8B%A4%EC%A0%9C-%EA%B5%AC%ED%98%84-1" aria-label="실제 구현 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>실제 구현</h2><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">const getUserInfoSaga = createAsyncSaga&lt;GetUserStartPayload, UserInfo, Error&gt;(
  userActions.getUserInfoSuccess,
  userActions.getUserInfoFail,
  userActions.getUserInfoRestore,
  {
    fn: getUserInfo,
    sustain: 2000,
  }
);

export function\* userSaga() {
  yield takeLatest(userActions.getUserInfo.type, getUserInfoSaga);
}</code>
        </deckgo-highlight-code><p>success, fail, restore 액션과 파라미터, 타입을 같이 넘겨 제네레이터 함수를 반환합니다. 마지막으로 takeLatest를 사용해 호출을 시작하는 start 액션을 구독하고 Saga와 맵핑시켜줍니다.</p><h1 id="디렉토리-구조" style="position:relative"><a href="#%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC-%EA%B5%AC%EC%A1%B0" aria-label="디렉토리 구조 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>디렉토리 구조</h1><p>아래와 같은 디렉토리 구조를 가집니다. 서버에서 관리하는 데이터의 도메인별로 Store을 나눕니다. 공통적으로 사용되는 유틸 함수(SagaUtil, createReducers)는 상위 디렉토리에 놓습니다.</p><p>컨벤션을 만들어 비동기 데이터를 가져오기 위해 필요한 reducer 함수들과 그렇지 않은 reducer 함수들을 공간적으로 분리할 수 있는 방법도 필요할 것입니다.</p><deckgo-highlight-code language="shell" theme="a11y-dark">
          <code slot="code">src
|- api
|- index.ts
|- store
|- user # 특정 도메인의 리듀서는 store 이하의 디렉토리로 분리
|- reducer.ts
|- types.ts
|- saga.ts
|- utils.ts
|- types.ts # store 전체에 사용되는 타입과 유틸함수는 store 디렉토리에 저장
</code>
        </deckgo-highlight-code><h1 id="전체-구현" style="position:relative"><a href="#%EC%A0%84%EC%B2%B4-%EA%B5%AC%ED%98%84" aria-label="전체 구현 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>전체 구현</h1><p>유틸 함수 부분과 실제 구현 부분으로 나누어 전체 구현 코드를 보여드리겠습니다. 확실히 Redux Toolkit 도입으로 <a href="https://maxkim-j.github.io/posts/how-to-use-redux-saga#%EC%93%B4%EB%8B%A4%EB%A9%B4-%EB%8D%94-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B4%90%EC%95%BC-%ED%95%A0-%EA%B2%83%EB%93%A4">이전 글의 Redux 예제</a>에 비해 간소화된 모습입니다.</p><p>저번 예제보다 개행이 많아서 라인 수 자체는 별로 차이가 나는  것 같지는 않지만, 전체적인 타이핑은 많이 줄었습니다. 액션 문자열과 액션 반환 함수를 정의할 필요가 없는게 제일 좋네요.</p><deckgo-highlight-code language="typescript" theme="a11y-dark">
          <code slot="code">// 실제 구현 부분

// index.ts
const initialStore: UserStore = {
userInfo: {
    data: null,
    GET: {
      status: &quot;idle&quot;,
      error: null,
    },
    POST: {
      status: &quot;idle&quot;,
      error: null,
    },
    PUT: {
      status: &quot;idle&quot;,
      error: null,
    },
  },
};

const userSlice = createSlice({
  name: &quot;user&quot;,
  initialState,
  reducers: {
    getUserInfo: createStartReducer(&quot;userInfo&quot;, &quot;GET&quot;)&lt;GetUserStartPayload&gt;(),
    getUserInfoSuccess: createSuccessReducer(&quot;userInfo&quot;,&quot;GET&quot;)&lt;UserInfo&gt;(),
    getUserInfoFail: createFailReducer(&quot;userInfo&quot;, &quot;GET&quot;)&lt;AxiosError&gt;(),
    getUserInfoRestore: createRestoreReducer(&quot;userInfo&quot;, &quot;GET&quot;)(),
  },
});

// saga.ts
export const userActions = userSlice.actions;

const getUserInfoSaga = createAsyncSaga&lt;GetUserStartPayload, UserInfo, Error&gt;(
  userActions.getUserInfoSuccess,
  userActions.getUserInfoFail,
  userActions.getUserInfoRestore,
  {
  fn: getUserInfo,
  sustain: 1000,
  }
);

export function\* userSaga() {
  yield takeLatest(userActions.getUserInfo.type, getUserInfoSaga);
}
</code>
        </deckgo-highlight-code><h1 id="맺는말" style="position:relative"><a href="#%EB%A7%BA%EB%8A%94%EB%A7%90" aria-label="맺는말 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>맺는말</h1><p>막상 정리해보면 내용이 그렇게 많지는 않은 것 같지만 근 몇달동안 상당히 골몰했던 주제였습니다. 회사에서의 태스크를 정신없이 처리하고 있어 짬이 쉽게 나지가 않았지만 내가 리덕스는 리팩토링 하고 만다!!!! 고 생각하며 벼르고 있었던 부분이기도 합니다.</p><p>부족한 결과이고 더 좋은 방법도 있을 것 같지만, 연구한 바를 점진적으로 회사 프로덕트에 적용해보며 수정/발전시키며 어느정도는 성과를 낸 것 같아 약간 뿌듯합니다.</p><p>하지만 React Query를 최근에 살펴보면서, Redux의 태생적인 한계가 눈에 많이 들어왔습니다. React Query가 제공해서 쉽게 쓸 수 있는 refetch, retry, caching 기능들을 Redux와 Saga에서 그대로 구현하고자 하면 정말 어려울 것입니다. 점진적으로 React Query나 SWR같은 라이브러리들로 비동기 요청 로직을 대체했으면 좋겠다는 생각이 큽니다.</p><p>기능을 빠른 시간 안에 붙여야 하는데 주니어 프론트엔드 개발자 2명이 있는 초기 스타트업이라 새로운 기술 도입을 진행할 시간이나 의견 확보가 쉽지 않았습니다. 그래도 거의 추가적인 기능을 못 붙일 상황까지 왔고 개선은 이루어져야 했기에, 생각해본 최선이 Redux를 그대로 두면서 Redux Toolkit을 도입하는 방법이었습니다. 설득에 성공했고, 비교적 무사히 진행하게 되서 다행이었습니다..</p><p>Redux + Saga로 비동기 관리하는 베스트 프랙티스 찾기가 꽤 힘이 듭니다.</p><p>구글링을 해보면 Success, Fail, Loading 관련한 상태를 기록하는 여러 방법들에 대해서는 찾을 수 있었지만 어느정도 만족할 수 있는 방법을 찾기까지 연구가 필요했던 것 같습니다.</p><p>Redux+Saga로 비동기를 관리하는 프로덕트를 만들고 계시는 분들께 조금의 인사이트가 되었으면 좋겠다는 바람입니다.</p></div><div><div class="c-inPSka"></div><div class="c-hLbyMm"><div>Written by 김맥스</div><div class="c-kINvOu"><a href="https://twitter.com/max_kim_dev">twitter</a><a href="https://github.com/MaxKim-J">github</a><a href="https://www.linkedin.com/in/%EC%A2%85%ED%98%81-%EA%B9%80-903967177/">linkedin</a></div></div><div class="c-inYmSa"><div>트위터에 공유하기</div><div>링크 복사하기</div></div><div class="c-gAHJmZ"><a href="/">글 목록으로 돌아가기</a><div class="c-eqDGAL"><a href="/posts/dev-job-retrospect">이전글</a><a href="/posts/react-native-ci-cd">다음글</a><a href="/posts/suspense-argibraic-effect">랜덤</a></div></div><div class="c-kxdqJo"></div></div></main><footer><div class="c-jPqceB"><div>김맥스 블로그ⓒ김종혁, 2022</div><div>Powered By <a href="https://www.gatsbyjs.com/">gatsby</a> /<a href="">gh-pages</a></div></div></footer></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-132859535-2', 'auto', {});
      
      
      
      
      
      }</script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/posts/redux-store-structure/";window.___webpackCompilationHash="4a53cd9132f76a934f57";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-f012ba4a76c3d692158a.js"],"app":["/app-9537a4856cd0b2a1dd44.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-1e045652be0e760ada58.js"],"component---src-pages-about-index-tsx":["/component---src-pages-about-index-tsx-31a350511f2323de75b8.js"],"component---src-pages-gallery-index-tsx":["/component---src-pages-gallery-index-tsx-0a570cc011ebe9b221fc.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-14d418d9f71cbfe772fb.js"],"component---src-pages-posts-mdx-slug-tsx":["/component---src-pages-posts-mdx-slug-tsx-db6a863d59075dfd4640.js"],"component---src-pages-tags-index-tsx":["/component---src-pages-tags-index-tsx-3d3d4d382476feb1beb8.js"]};/*]]>*/</script><script src="/polyfill-f012ba4a76c3d692158a.js" nomodule=""></script><script src="/app-9537a4856cd0b2a1dd44.js" async=""></script><script src="/framework-0ea894b592cd5d21d3c6.js" async=""></script><script src="/webpack-runtime-d32edc4e0e016ccc93cc.js" async=""></script></body></html>